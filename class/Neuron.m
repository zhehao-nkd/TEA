 classdef Neuron < handle
    %ANALYSIS Summary of this class goes here
    %   Detailed explanation goes here
 
    properties
        e
        plxname
        channelname
        unitname
        neuronname
        slist % sound list
        lieshu
        hangshu
        mergedeleinf
    end
    
    methods
        
        function n = Neuron(neuron, path_plx, folder_wav)
            dbstop if error
            
             
        %             for m = 1: length(neurons) % for each neuron
        %                 sp = Spike(neurons{m});
        %
        %                 temp = struct;
        %                 parfor n = 1: length(songs)
        %                     so = Sound(songs{n});
        %                     temp(n).e = Ephys2(sp,t,so);
        %                 end
        %                 temp2 = [temp.e];
        %             end
           
            songs = Sound.split(folder_wav);
            t = Trigger(path_plx);
            temp1 = unique(neuron.channelname);
            n.channelname = temp1{1};
            n.unitname= unique(neuron.unit);
             
            
            [~,n.plxname,~] = fileparts(path_plx);
            n.neuronname = sprintf('%s_%s_%u',n.plxname,n.channelname,n.unitname);
            
            % for this neuron
            sp = Spike(neuron); % here the neuron is a separatedT generated by spike.split
            
            sp.set_ephys_fs(t.ephys_fs); % set sampling rate of ephys signal
            
            %sp.cal_wavelength？》？？？？？？？？？ calculate wavelength
            
           
           for k = 1: length(songs)   %%% should be parfor!!!!!!!!!!
                
                    so = Sound(songs{k});
                    e{k} = Ephys(sp,t,so);
                
            end
            n.e = e;  % maybe because the connection to the bucket is dead
            
            n.gets; % get a list of all songs
            
            
            n.lieshu =7;
            n.hangshu = ceil(length(n.e)/n.lieshu);
            
%             if isempty( find(~cellfun(@isempty, regexp([n.slist(:).name].','deg')) ) % if no deg stimuli
%                 n.fix_segmentation;  % replace the initials/terminals using those from exported .mat file
%                 n.find_ele_elicit_response;
%             end
        end
          
        function sigonly = siginf(n)
            
            collect = cellfun(@(obj) obj.siginf, n.e,'UniformOutput',false);
            sigonly =  horzcat(collect{:});
            
        end
        
        function rank = picksongs(n)
            img = three(n);
            ax = gca;
            fig = ancestor(ax, 'figure');
           
            
            imshow(img)
            xlabel(ax,'Right click your mouse after labeling!') ;
            xs =[];
            ys = [];
            hold(ax, 'on');
            while true
                [x,y] = ginput(1);
                sel = get(fig, 'SelectionType');
                if strcmpi(sel, 'alt'); break; end
                scatter(x,y,100,'green');
                xs = [xs,x];
                ys = [ys,y];
            end
            hold(ax, 'off')
            
            [hei,wei,~] = size(img) % height and weight of the concatenated figure
            
            for f = 1: length(xs)
               lienum =  ceil(ys(f)/(hei/n.hangshu))
               hangnum = ceil(xs(f)/(wei/n.lieshu))
               rank(f) = (lienum - 1)*n.lieshu + hangnum;
            end
            
            
            % get the figure size
            
        end
        
        function sylinf = sylinf(n)
  
%             collect = cellfun(@(obj) obj.sylinf, n.e,'UniformOutput',false);
%             sylinf =  horzcat(collect{:});
            
            tic;
            disp(sprintf('Current neuron is %s',n.neuronname)); %#ok<DSPS>
            
            for idx = 1: length(n.e)
                collect{idx} = n.e{idx}.sylinf;
            end
            sylinf =  horzcat(collect{:});
            
            toc;
            newline;
            
        end
        
        function sylinf = sapsylinf(n)
            dbstop if error
            tic;
            disp(sprintf('Current neuron is %s',n.neuronname)); %#ok<DSPS>
            
            for idx = 1: length(n.e)
                collect{idx} = n.e{idx}.sapsylinf;
            end
            sylinf =  horzcat(collect{:});
            
            toc;
            newline;
        end
        
        function siginf = mansiginf(n)
           spikeinf = manspike(n);
           
           for kk = 1: length(spikeinf)
           end
           
        end
        
        function sigfrag = manpicksig(n) % mannually pick up response eliciting syllable/element
            
            for kk = 1: length(n.e)
                n.e{kk}.three;
                roi = drawline;
            end
        end
        
        function spikeinf = manspike(n) % manually screen significant spike events
            num = 0;
            for idx = 1: length(n.e)
                %fig = figure;
               
                %WindowAPI(fig, 'full');
                %fig.WindowState = 'maximized';
                n.e{idx}.three;
                set(gcf,'units','normalized','outerposition',[0 0 1 1])
                [x,y] = ginput;
                for kk = 1: length(x)
                    num = num + 1;
                    spikeinf(num).t = x(kk)-n.e{idx}.pltext;  % spike time relative to the initial of the song
                    spikeinf(num).peak = y(kk); % spike peak
                    spikeinf(num).soundname = n.e{idx}.sound.name;
                    spikeinf(num).neuronname = n.neuronname;
                    
                end
                close(gcf);
            end
            
        end
        
        function siginf = sapsiginf(n)
           sylinf = n.sapsylinf;
           
           idx = find([sylinf.label].');
           siginf = sylinf(idx);
            
        end
        
        function sapsigspec(n)
            siginf = n.sapsiginf;
            gap = zeros(0.05*32000,1);
            concatenated = gap;
            
            for idx = 1: length(siginf)
                concatenated = [concatenated;siginf(idx).y;gap];
            end
            figure('Color','w');
            draw.spec(concatenated,32000);
            
        end
        
        function sapscatter(n)  % function to generate scatter plot based on sapsylinf
            sapsylinf = n.sapsylinf;
            idx = find ([sapsylinf.label] ==1);
            labeled = sapsylinf(idx);
            
            figure('Color','w','Position',[1946 -103 1178 1086]);
            scatter([sapsylinf.pitch].',[sapsylinf.fm].','k','filled');
            
            hold on
            
            scatter([labeled.pitch].',[labeled.fm].','r','filled');
            
            xlabel('Pitch');
            ylabel('FM');
            title(n.neuronname);
            saveas(gcf,sprintf('Scatter-%s.png',n.neuronname));
            pause(0.5)
            close(gcf);
        end
     
        function sylT = sylinfsl(n) % same length
            
            tic;
            disp(sprintf('Current neuron is %s',n.neuronname)); %#ok<DSPS>
            parfor idx = 1: length(n.e)
                collect{idx} = n.e{idx}.sylinfq;
            end
            syl =  horzcat(collect{:}).';
            
            parfor idx = 1: length(syl)
                len(idx) = length(syl(idx).y);
            end
            syl(len> pa.SYLLEN) = []; % remove longer syllables
            
            parfor id = 1: length(syl)
                syl(id).y = utl.pad(syl(id).y,pa.SYLLEN); % pad to 12800
                syl(id).image = cal.img(syl(id).y,syl(id).fs); % store the image matrix
                temp = extract.feature(syl(id).y,syl(id).fs);
                syl(id).goodness = temp.goodness;
                syl(id).meanf = temp.mean_frequency;
                syl(id).fm = temp.fm;
                syl(id).amplitude = temp.amplitude;
                syl(id).entropy = temp.entropy;
                syl(id).pitch = temp.pitch;
                syl(id).rawpitch = temp.rawpitch;
                syl(id).am = temp.AM;

              
            end
            sylT = struct2table(syl);
            newline;
            toc;
            
        end
        
        function sylT = sylinfsld(n) % same length% downsample
            
            
            tic;
            disp(sprintf('Current neuron is %s',n.neuronname)); %#ok<DSPS>
            parfor idx = 1: length(n.e)
                collect{idx} = n.e{idx}.sylinfq;
            end
            syl =  horzcat(collect{:}).';
            
            parfor idx = 1: length(syl)
                len(idx) = length(syl(idx).y);
            end
            syl(len> pa.SYLLEN) = []; % remove longer syllables
            
            parfor id = 1: length(syl)
                syl(id).y = utl.pad(syl(id).y,pa.SYLLEN); % pad to 12800
                %syl(id).image = cal.img(syl(id).y,syl(id).fs); % store the image matrix
                temp = extract.feature(syl(id).y,syl(id).fs);
                drate = 3; % downsampling rate
                syl(id).goodness = downsample(temp.goodness,drate);
                syl(id).meanf = downsample(temp.mean_frequency,drate);
                syl(id).fm = downsample(temp.fm,drate);
                syl(id).amplitude = downsample(temp.amplitude,drate);
                syl(id).entropy = downsample(temp.entropy,drate);
                syl(id).pitch = downsample(temp.pitch,drate);
                %syl(id).rawpitch = downsample(temp.rawpitch,drate);
                syl(id).am = downsample(temp.AM,drate);

            end
            sylT = struct2table(syl);
            newline;
            toc;
            
        end
        
        function n = gets(n) % get sound list
            for idx = 1: length(n.e)
                n.slist(idx).idx = idx;
                n.slist(idx).name = n.e{idx}.sound.name;
            end
            n.slist = n.slist';
        end
        
        function showsigspec(n)
            siginf = n.siginf;
            gap = zeros(0.05*32000,1);
            concatenated = gap;
            
            for idx = 1: length(siginf)
                concatenated = [concatenated;siginf(idx).y;gap];
            end
            figure('Color','w');
            draw.spec(concatenated,32000);
        end
        
        function response = resp(n) % mimic old response
            
            collect = cellfun(@(obj) obj.resp, n.e,'UniformOutput',false);
            response =  horzcat(collect{:}).';
            
        end
        
        function syl = avgn(n)
            %collect = cellfun(@(obj) obj.avgn, n.e,'UniformOutput',false);
            % cellfun is slow
            tic;
            disp(sprintf('Current neuron is %s',n.neuronname)); %#ok<DSPS>
            parfor idx = 1: length(n.e)
                collect{idx} = n.e{idx}.avgn;
            end
            syl =  horzcat(collect{:});
            
           
            newline;
            toc;
            
        end
             
        function pre = preinf(n)
            collect = cellfun(@(obj) obj.preinf, n.e,'UniformOutput',false);
            pre =  horzcat(collect{:}).';
        end
        
        function prespec(n) % draw the spectrogram of the pre-peak stimuli durations
            pre = n.preinf;
            
            
            edges = [];
            sumy = [];
            thisedge = 0;
            for idx = 1: length(pre)
                sumy = [sumy;pre(idx).y];
                thisedge = thisedge + length(pre(idx).y);
                edges = [edges,thisedge];
            end
            figure; 
            sumy(isnan(sumy))=0; % convert nan to 0
            draw.spec(sumy,pre(1).fs);
            
            for idx = 1: length(edges)
                xpair = repmat(edges(idx),2,1);
                ypair = [0,16];
                hold on
                line(xpair/pre(1).fs,ypair,'color','r');
            end
   
%             figure;
%             for idx = 1: length(pre)
%                 subplot(length(pre),1,idx);
%                 draw.spec(pre(idx).y,pre(idx).fs);
%                 xlabel('');
%                 ylabel('');
%                 set(gca,'xtick',[],'ytick',[])
%                 set(gca,'xticklabel',[],'yticklabel',[])
%             end
            
        end
              
        function IMG = three(n) % draw three plot
            
            for idx = 1: length(n.e)
                n.e{idx}.three_with_sig_resp; % newer version of threeplot drawing method
                frame = getframe(gcf);
                I{idx} = frame.cdata;
                close(gcf);
            end
            
            % draw blank white
%             lieshu = 9;
%             hangshu = ceil(length(I)/lieshu);
            rest = n.lieshu*n.hangshu - length(I);
            white = uint8(255*ones(size(I{1})));
            
            if rest > 0
                for k = 1:rest
                    I = [I,white];
%                     ax = gcf;
%                     ax.Position(3) = 560;
%                     ax.Position(4) = 420;
                end
            end
            
            reshapedI = reshape(I, n.lieshu,[])';     
            clear I     
            IMG = cell2mat(reshapedI);
            imwrite(IMG,sprintf('Three_%s.png',n.neuronname));
            
        end
        
        function IMG = rawthree(n) % draw three plot
            
            for idx = 1: length(n.e)
                n.e{idx}.rawthree;
                frame = getframe(gcf);
                I{idx} = frame.cdata;
                close(gcf);
            end
            
            % draw blank white
%             lieshu = 9;
%             hangshu = ceil(length(I)/lieshu);
            rest = n.lieshu*n.hangshu - length(I);
            white = uint8(255*ones(size(I{1})));
            
            if rest > 0
                for k = 1:rest
                    I = [I,white];
%                     ax = gcf;
%                     ax.Position(3) = 560;
%                     ax.Position(4) = 420;
                end
            end
            
            reshapedI = reshape(I, n.lieshu,[])';     
            clear I     
            IMG = cell2mat(reshapedI);
            imwrite(IMG,sprintf('RawThree_%s.png',n.neuronname));
            
        end
        
        function IMG = threesingle(n)
            wb = waitbar(0,'writting three plots...');
            for idx = 1: length(n.e)
                waitbar(idx/length(n.e),wb,'writting three plots...');
                n.e{idx}.threesingle;
                frame = getframe(gcf);
                I{idx} = frame.cdata;
                close(gcf);
            end
            close(wb);
            rest = n.lieshu*n.hangshu - length(I);
            white = uint8(255*ones(size(I{1})));
            
            if rest > 0
                for k = 1:rest
                    I = [I,white];
                end
            end
            
            reshapedI = reshape(I, n.lieshu,[])';
            clear I
            IMG = cell2mat(reshapedI);
            pause(0.2)
            imwrite(IMG,sprintf('Three_%s.png',n.neuronname));
        end
        
        function drawpre(n)
            pre = preinf(n);
            feature = {'pitch'};
            
            for feaN = 1: length(feature)
                
                featurename = feature{feaN};
                
                featurecell = eval(['{pre.',feature{feaN},'}.''']);
                allfea = horzcat(featurecell{:});
                
                allfea(allfea==0)=[];
                allfea(allfea==inf)=[];
                allfea(isnan(allfea))=[];

                
                figure('color','w','visible','off');
                ax = gcf;
                ax.Position(3) = 1120;
                ax.Position(4) = 840;
                
                data = cell2mat(eval(['{pre.',feature{feaN},'}.''']))';
                data(data == inf|data == -inf|data == 0) = NaN;
                
                %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                 
%                 controldata = {};
%                 PDFcontrol = {};
%                 tic
%                 parfor conN = 1
%                     controlprespike = featureAlignControl2(response,range,length(prespike),feature{feaN});
%                     controldata{conN} = cell2mat({controlprespike.thefeature}.')';
%                     
%                     controldata{conN}(controldata{conN} == inf|controldata{conN} == -inf|controldata{conN} == 0) = NaN;
%                     [~,PDFcontrol{conN},~] = estDensityThesis(controldata{conN},prespike,1,featurename,1);
%                     %disp(conN)
%                 end
%                 toc
                
%                 sumPDF =  horzcat(PDFcontrol{:});
%                 %     figure
%                 %     histogram( max(sumPDF),'Normalization','Probability' );
%                 
%                 [countN, bedges] =  histcounts( max(sumPDF),'Normalization','Probability' );
%                 
%                 bin = 0;
%                 probablity = 0;
%                 while probablity < 0.95
%                     bin = bin + 1;
%                     probablity = probablity + countN(bin);
%                 end
%                 
%                 threshold = ( bedges(bin) + bedges(bin+1) )/2;
%                 
                
                %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                [Ia,DFdata,limcolor] = estDensityThesis(data, pre, [],featurename);
                
                
                figure;
                plot(data);
                tempI = getframe(gcf);
                Itrace{feaN} = tempI.cdata;
                
                %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% last part
                Ifea{feaN} = Ia;
                
                close(gcf);
            end
            
            I = vertcat(Ifea{:});
            
        end  % have to modify a lot to use this function
        
        function collect = extractstimuli(n)
            
              tic;
            disp(sprintf('Current neuron is %s',n.neuronname)); %#ok<DSPS>
            parfor idx = 1: length(n.e)
                %collect{idx} = n.e{idx}.y;
                figure('Visible','off')
                draw.spec(n.e{idx}.y,n.e{idx}.fs);
                temp = getframe(gcf);
                I = temp.cdata;
                collect{idx} = rgb2gray(I);
            end
           
            newline;
            toc;
        end
        
        function collect = extractsdf(n)
            
              tic;
            disp(sprintf('Current neuron is %s',n.neuronname)); %#ok<DSPS>
            parfor idx = 1: length(n.e)
                collect{idx} = cal.sdf(n.e{idx}.sptimes,n.e{idx}.y,n.e{idx}.fs);
            end
           
            newline;
            toc;
        end
        
        function featuretsne(n)
            dbstop if error
            outdir = 'feature_tsne';
            mkdir(outdir);
            syl = n.sylinfsl;
            label =syl.label;
            idx = find(label);
            
            
            feature = {'am','fm','pitch','amplitude','meanf','goodness','entropy'};
            
            for f = 1: length(feature)
                tested = eval([ 'syl.',feature{f},';']);
                
                coordi = tsne(tested);
                if isempty(coordi)
                    continue
                end
                figure;
                scatter(coordi(:,1),coordi(:,2),[],[0.5 0.5 0.5],'filled');
                hold on
                
                labcoordi = coordi(idx,:);
                scatter(labcoordi(:,1),labcoordi(:,2),[],'b','filled');
                filename = sprintf('%s_%s',n.neuronname,feature{f});
                 
                xlabel( filename);
                hold off
               
                saveas(gcf,[outdir,'/',filename,'.png']);
                close(gcf)
            end
        end
            
        function trg = trg4nex(n)
            k = 0;
            for idx = 1: length(n.e)
                if ~isempty(n.e{idx})
                    k = k + 1;
                    trgnum = n.e{idx}.sound.trigger;
                    trg(k).name = n.e{idx}.sound.name;
                    selected = find ([n.e{idx}.trigger.info.name] == trgnum);
                    trg(k).tgime = n.e{idx}.trigger.info(selected).time;
                    
                end
            end
            trg = trg';
            trgt = struct2table(trg);
            writetable(trgt, 'TRG_tocopy.csv','WriteRowNames',false,'WriteVariableNames',false)
        end
        
        function len = sylnum(n)
            len = 0;
              for idx = 1: length(n.e)
                 len = len + n.e{idx}.sylnum; 
              end
        end
        
        function ssinfo = singlesylinf(n)
            
            for h = 1: length(n.e)
                thise = n.e{h};
               ssinfo(h).plty = thise.plty;
               ssinfo(h).pltsptimes = thise.pltsptimes;
               ssinfo(h).sptimes = thise.sptimes;
               ssinfo(h).fs = thise.fs;
               ssinfo(h).name = thise.sound.name;
               temp = strsplit(thise.sound.name,'_');
               temp = temp{1};
               temp = strsplit(temp,'-');
               ssinfo(h).songname = temp{2};
               ssinfo(h).fragid = str2num(temp{3});
            end
            
            ssinfo = table2struct(sortrows(struct2table(ssinfo),{'songname','fragid'}));
            
        end
        
        function info = todisplay(n)
            
            for k = 1: length(n.e)
                
                info(k).stimuliname = n.e{k}.sound.name;
                
                info(k).fs = n.e{k}.fs;
                
                info(k).plxname = n.e{k}.trigger.plxname;
                info(k).channelname = n.channelname;
                info(k).unitname = n.e{k}.spike.unit;
                
                info(k).y = n.e{k}.y;
                info(k).rawy = n.e{k}.rawy;
                info(k).plty = n.e{k}.plty;
                
                info(k).sptimes = n.e{k}.sptimes;
                info(k).rawsptimes = n.e{k}.rawsptimes;
                info(k).pltsptimes = n.e{k}.pltsptimes;
                info(k).zpt = n.e{k}.zpt; % zero point time
                
                info(k).pltext = n.e{k}.pltext;
                
            end
        end
        
        function latency = cal_latency(n) % to estimate latency of this neuron 
            % But I am afraid that this function may not work very well
            latency_collect = []; % for summation and average of all the latency values
            y = 0; % counter for the latency
            
            for q = 1: length(n.e)
                if ismember(1,n.e{q}.sig) % if 1 is the member : means when this neuron respond to the first element
                    
                    % here the sig function, as I read the its calculation,
                    % is to find the nearest initial before peak location
                    % in time dimension
                    y = y + 1;
                    latency_collect(y) = n.e{q}.sigloc(1); % equals to the latency
                end
            end
           latency =  min(latency_collect);
            
        end
        
        function fix_segmentation(n) % to fix the segmentation of songs into elements
            
            folders = extract.folder("C:\Users\Zhehao\Dropbox (OIST)\My_Stimuli");
            
             temp = regexp(n.plxname,'[BRYOG]\d{3}','match');
             birdid = temp{1};
             
             if  ~isempty(find(~ cellfun(@isempty,regexp([folders{:}],birdid)))) % if folder is there
                 
                 thatfolder = folders{find(~ cellfun(@isempty,regexp([folders{:}],birdid)))}; % corresponding folder of the bird
                 load(sprintf('%s\\mergedeleinf.mat',thatfolder));
                 
                 
                 for r = 1: length(n.e)
                     linshi = split(n.e{r}.sound.name,'-');
                     name_to_search = linshi{2};
                     
                     local_ids = find(~cellfun(@isempty,regexp([mergedeleinf.songname].',name_to_search )));
                     
                     
                      zerobegin_mat = [mergedeleinf(local_ids).initial ].'-mergedeleinf(local_ids(1)).initial;
                      zerobegin_mat_terminal = [mergedeleinf(local_ids).terminal ].'-mergedeleinf(local_ids(1)).initial
                      first_initial = n.e{r}.sound.initial(1);
                      
                      
                     n.e{r}.sound.initial = first_initial + zerobegin_mat;
                     n.e{r}.sound.terminal = first_initial +  zerobegin_mat_terminal;
                 end
             end
        end
            
        
        function find_ele_elicit_response(n) % return the index of the element which trigger neural response
            
            latency = cal_latency(n);
            
            for k = 1: length(n.e)
                locs_of_this_song = n.e{k}.sigloc; % time location of neural response peak of this stimuli
                
                if ~isempty(latency)
                    locs_of_this_song = locs_of_this_song - latency; %!!!!!!  - latency!~!!!
                end
                    
                initials = ( n.e{k}.sound.initial -n.e{k}.sound.initial(1) )/n.e{k}.fs; % normalize the initials
                plt_initials = ( n.e{k}.sound.initial -n.e{k}.sound.initial(1) )/n.e{k}.fs + n.e{k}.pltext;
                plt_terminals = ( n.e{k}.sound.terminal -n.e{k}.sound.initial(1) )/n.e{k}.fs+ n.e{k}.pltext;
                if ~isempty(locs_of_this_song)
                    
                    n.e{k}.three
                    hold on
                    
                   % draw segmentation lines 
                   
                   for p = 1: length(plt_initials)
                       xline(plt_initials(p),'Color','g');
                       xline(plt_terminals(p),'Color','y');
                   end
                    
                    
                    for v = 1:length(locs_of_this_song)
                        %figure;
                        subplot(3,1,3)
                        xline(locs_of_this_song(v)+  n.e{k}.pltext);               % - latency!~!!!
                        ele_idx_of_this_song(v) = length(find(locs_of_this_song(v)>initials)); % return the idx of the significant syllables
                        disp(length(find(locs_of_this_song(v)>initials)));
                        n.e{k}.eliciting_element_counting_whole = ele_idx_of_this_song; % modify the Ephys-Object from outside
                        disp('标记1');
                    end
                end
                disp('标记2');
                close(gcf);
            end
            
        end
        
        
        function eleinf = recover_eleinf(n) % recover the struct named eleinf from thr Neuron object
           dbstop if error
            % case 1: when wav file does not contain the segmenation info
            
             folders = extract.folder("C:\Users\Zhehao\Dropbox (OIST)\My_Stimuli");
              temp = regexp(n.plxname,'[BRYOG]\d{3}','match');
              birdid = temp{1};
              
            if  ~isempty(find(~ cellfun(@isempty,regexp([folders{:}],birdid))))
                thatfolder = folders{find(~ cellfun(@isempty,regexp([folders{:}],birdid)))}; % corresponding folder of the bird
                load(sprintf('%s\\mergedeleinf.mat',thatfolder));
            end
                 
            
            % remove non-CON elements including BOS and also TUT
           ids_to_delete =  find( ~cellfun(@isempty,regexp([mergedeleinf(:).songname].','Fcall|Het|Mcall|WNS|BOS|TUT')) );
            
           % load and convert coordinate 1 and 2
            mergedeleinf(ids_to_delete)= [];
%              [~,encodezpath] = uigetfile;
%               load(encodezpath);
              
              load("C:\Users\Zhehao\Dropbox (OIST)\My_Stimuli\SourceSongSet1@06232021\vrae_birdsong_data.mat");
                 
              for x = 1: length(mergedeleinf)
                  mergedeleinf(x).coor_1 = Z_embedded(x,1);
                  mergedeleinf(x).coor_2 = Z_embedded(x,2);
              end
              
              eleciting_info = extract_eleciting_info(n);  % get the index of response-eliciting element
              
              for k = 1: length(n.e)
                  % SAVE THE SPEC AND ALSO THE RASTER DATA
                  
                  temp = split(n.e{k}.sound.name,'-');
                  temp = temp{2};
                  
                  this_ids = find(~cellfun(@isempty, regexp([mergedeleinf(:).songname].',temp)));
                  
                  specimg = cal.spec(n.e{k}.rawy,n.e{k}.fs);
                  x      = 0;   % Screen position
                  y      = 0;   % Screen position
                  width  = size(specimg,2); % Width of figure
                  height = size(specimg,1); % Height of figure (by default in pixels)
                  
                  %rasterfig = figure( 'Position', [x y 2974 2974*height/width], 'Visible', 'off');
                    rasterfig = figure( 'Position', [x y 2974 200], 'Visible', 'off');
                  %figure
                  box off
                  set(gca, 'Visible', 'off')
                  draw.raster(n.e{k}.rawsptimes,n.e{k}.rawy,n.e{k}.fs);
                  F = getframe(rasterfig);
                  [rasterimg, ~] = frame2im(F);
                  rasterimg = imbinarize(rasterimg);
                  % figure; imshow(rasterimg)
                  EXTENSION = 0.060; % 60 ms exntension
                  for cao = 1:  length(this_ids)
                      ini_percentage = (mergedeleinf(this_ids(cao)).initial-mergedeleinf(this_ids(1)).initial + n.e{k}.sound.initial(1)) /length(n.e{k}.rawy);
                      ter_percentage = (mergedeleinf(this_ids(cao)).terminal-mergedeleinf(this_ids(1)).initial + n.e{k}.sound.initial(1) + EXTENSION*n.e{k}.fs) /length(n.e{k}.rawy);
                      
                     mergedeleinf( this_ids(cao)).rawspec = specimg(:,size(specimg,2)*ini_percentage:size(specimg,2)*ter_percentage);
                     mergedeleinf( this_ids(cao)).rawraster = rasterimg(:,size(rasterimg,2)*ini_percentage:size(rasterimg,2)*ter_percentage); 
                     % figure; imshow(mergedeleinf( this_ids(cao)).rawspec)
                       % figure; imshow(mergedeleinf( this_ids(cao)).rawraster)
                  end
              end
              
              
             
              
              % initiate wholecountsiglabel as 0
              for cnm = 1: length(mergedeleinf)
                  mergedeleinf(cnm).wholecountsiglabel = 0;
              end
              
              for y = 1: length(eleciting_info)              
                  
                  if ~isempty( eleciting_info(y).eleciting)
                      
                      samesongids =  find(~cellfun(@isempty, regexp([mergedeleinf(:).songname].',eleciting_info(y).name)));
                      for z = 1: length(eleciting_info(y).eleciting)
                          samefrgids = find(arrayfun(@(s) ismember(s,eleciting_info(y).eleciting), [mergedeleinf(:).fragid].' ));
                          ids_to_label = intersect(samesongids,samefrgids);
                          for wtf = 1: length(ids_to_label)
                              mergedeleinf(ids_to_label(wtf)).wholecountsiglabel = 1;
                          end
                      end
                  end
              end
              
            eleinf = mergedeleinf;  
              % case 2: when wav file contain the segmentation info
            
        end
        
        function eleciting_info = extract_eleciting_info(n) % extract information of response-eleciting element from Ephys objects
            
            eleciting_info = struct;
            
            for w = 1: length(n.e)
               %temp = regexp(n.e{w}.sound.name,'[BRYOG]\d{3}','match');
               temp = split(n.e{w}.sound.name,'-');
               eleciting_info(w).name = temp{2};
               eleciting_info(w).eleciting = n.e{w}.eliciting_element_counting_whole; 
            end
        end
        
        function spec_space = back_analysis_spectral_space(n)
            
            
          mergedeleinf = recover_eleinf(n);
          n.mergedeleinf = mergedeleinf;
          eleinf = mergedeleinf;
          figure;
          hold on
          for f = 1: length(eleinf)
              
              if eleinf(f).wholecountsiglabel == 1
                  scatter(eleinf(f).coor_1,eleinf(f).coor_2,[],'r')
              else
                  scatter(eleinf(f).coor_1,eleinf(f).coor_2,[],'b')
              end
          end
          
          close(gcf)
          % draw spectrum in space
          cmap = jet;
          
%           cmap = [0.2 0.1 0.5
%               0.1 0.5 0.8
%               0.2 0.7 0.6
%               0.8 0.7 0.3
%               0.9 1 0];
%           
          spec_space = figure
          set(gca,'Color','w')
          hold on
          axis([min([eleinf.coor_1]) max([eleinf.coor_1]) min([eleinf.coor_2]) max([eleinf.coor_2])])
          
          for w = 1: 100
%               tempimg = cal.spec(eleinf(w).y,eleinf (w).fs);
%               tempimg = tempimg(80:250,:);
            tempspecimg = eleinf(w).rawspec;
            tempspecimg= tempspecimg(5:220,:);
            temprasterimg = eleinf(w).rawraster;
            temprasterimg = imresize(temprasterimg,size(tempspecimg));
            
            tempimg = vertcat(tempspecimg,temprasterimg);
            
              [alpha,beta] = size(tempimg);
              
              img = imresize(flip(tempimg,1),[alpha,beta*2]);
              
              [M,N] = size(img);
              block_size = 50;
              P = ceil(M / block_size);
              Q = ceil(N / block_size);
              alpha = checkerboard(block_size,  P, Q) > 0;
              alpha = alpha(1:M, 1:N);
              alpha = img;

              %     figure
              %     draw.spec(all_eleinf(w).y,all_eleinf(w).fs);
              try
                  if length(eleinf(w).y)  > 50
                      
                      if eleinf(w).wholecountsiglabel == 0
                          
                            h = subimage(eleinf(w).coor_1*200,eleinf(w).coor_2*200,img*1);
                             set(h, 'AlphaData', 0.7);
                      elseif eleinf(w).wholecountsiglabel == 1
                      
                      h = subimage(eleinf(w).coor_1*200,eleinf(w).coor_2*200,img*10,cmap(1:12:end,:));
                       set(h, 'AlphaData', 0.7);
                      end
                      %colormap(ax,'jet')
                      %scatter(all_eleinf(w).xfake,all_eleinf(w).yfake);
                      drawnow
                  end
              catch error
              end
              
          end
         
         % axis([min([eleinf.coor_1]) max([eleinf.coor_1]) min([eleinf.coor_2]) max([eleinf.coor_2])])
         %
          
        end
        
        function update_catego_for_each(n)
            coor_1 = [n.mergedeleinf.coor_1].'; coor_2 = [n.mergedeleinf.coor_2].';
            coordinate = horzcat(coor_1,coor_2);
            
            distance = [];
            
            for indi = 1: length(coordinate)
                
                for a = 1: length(coordinate)
                    distance(a) = norm(coordinate(a,:) - coordinate(indi,:));
                end
                
                [B,I] = maxk(distance,10);
                
                
                cloest = coordinate(I,:);
                
                uni_id_cloest = [n.mergedeleinf(I).fragid].';  % the unique id of element which is most cloest 10 element to current element
                n.mergedeleinf(indi).closest10 = uni_id_cloest;
                %try to verift this part
                %
                %             figure;
                %             scatter(coordinate(:,1),coordinate(:,2));
                %             hold on
                %             scatter(cloest(:,1),cloest(:,2));
                
            end
    
        end 
            
    end
end


