% Scratch 30 This a scratch to show all the steps necessary for generating
% stimuli, and analye the neural response to the stimuli

%(((^>^))) This section is for fitering bucket folders, only select those
%good folders
dbstop if error
fs = 32000;
b = Bird("Z:\Yazaki-SugiyamaU\Bird-song"); % bi is the Bird object
b.rand % randomize the folder paths
goodfolders = b.folders;
ConDirs = fromWavFindParentFolder("C:\Users\Zhehao\Dropbox (OIST)\My_Stimuli\O684@test@20211019");
Confolders = ConDirs; % Overwrite goodfolders

%To place confolders at the front
[Lia,locb] = ismember([Confolders{:}].',[goodfolders(:)]);
new_ids = vertcat(locb(locb>0),setdiff([1: length(goodfolders)],locb(locb>0)).'); %v new ids which place ConFolders in the front
goodfolders = goodfolders(new_ids).';


%(((^_^))) This section is for copy .wav files from bucket to my PC, and
%this will be applied for each bird
tic
for f = 408: length(goodfolders)
    output_dir = bucketMover(goodfolders{f}); % blue137 (f = 25)contains too many files !!!
    fprintf('Number __%u__ in %u folders\n',f,length(goodfolders));
    disp('草如劍形，上有七星，列如北斗');
end
toc


%(((^~^))) This section is for segmenting copied songs into elements. 
wav_dir = "E:\WavsCollection";
%wav_dir = "E:\Fake_Try";
subdirs = Extract.folder(wav_dir);
tic
for r = 1:length(subdirs)
    
   if ~isempty(Extract.filename(sprintf('%s\\SegData',subdirs{r}),'*.mat'))
       continue
   end
    autosegmenter_restrict_bout(subdirs{r},5);
    
    fprintf('Now__%u__of %u dirs are processed',r,length(subdirs));
end
toc


send_mail_message('379380788@qq.com','First section finished','Oops')


for r = 1:length(subdirs)
    
   if ~isempty(Extract.filename(sprintf('%s\\SegDataIndi',subdirs{r}),'*.mat'))
       continue
   end
    autosegmenter(subdirs{r});
    
    fprintf('Now__%u__of %u dirs are processed',r,length(subdirs));
end
toc



%(((^~^))) Convert segdata files into eleinf, and then Convert eleinf into
%the format suitable for the python script
ote_sylinf = assemble_as_eleinf(subdirs,300,'SegData'); % 300 means remove folderes with bird id smaller than 300
ote_sylinf = addcategoinfo(ote_sylinf); % add catego info into the eleinf
%unique_sylinf = stimuli.unique_it( ote_sylinf );

conspe_sylinf = autoseg("C:\Users\Zhehao\Dropbox (OIST)\My_Stimuli\Y687@10252021").singleSegmenterSyl;


temp_con = conspe_sylinf;
for k = 1: length(temp_con)
    temp_con(k).len = length(temp_con(k).y);
end 
cont = struct2table(temp_con); % Here I should find the max and min length of eleinf!!!


% remove too long or too short elements
for k = 1: length(unique_sylinf)
    unique_sylinf(k).len = length(unique_sylinf(k).y);
end

rm_eleinf = unique_sylinf(find(4000 >[unique_sylinf.len].'& [unique_sylinf.len].'> 700));

% I comment this part because I need those from the con_eleinf to write
% elements which are just from the same bird ( but in different motifs )

% % to further remove eles which have the same name with con_eleinf
% ConDirs = fromWavFindParentFolder("C:\Users\Zhehao\Dropbox (OIST)\My_Stimuli\Y687@10252021").';
% con_spe_names = {};
% for zeno = 1: length(ConDirs)
%    splitted = split( ConDirs{zeno},'\');
%    con_spe_names{zeno} = splitted{end};
% end
% pure_songname = {};
% for ee = 1: length(rm_eleinf)
%     temp = rm_eleinf(ee).songname;
%     temp = split(temp,'-');
%     pure_songname{ee} = temp{end};
% end
% Lia = find(~ismember(pure_songname,con_spe_names));
% rm2_eleinf = rm_eleinf(Lia); % fuether filtere eleinf

con_eleinf = conspe_sylinf(find(cellfun(@isempty,regexp([conspe_sylinf.songname].','Mcall|Het|Fcall|WNS'))));

all_eleinf = horzcat(con_eleinf,rm_eleinf);
for p = 1: length(all_eleinf)
    all_eleinf(p).uniqueid = p;
end

preprocessVrae(all_eleinf); % this code will write labeled_eleConOnly.mat

% Here I should load the coor_Z trained by the neural network
for p = 1: length(all_eleinf)
    all_eleinf(p).coor_1 = coor_Z(p,1);
    all_eleinf(p).coor_2 = coor_Z(p,2);
end



%(((@_@)))Then load eleinf generated by python code -VRAE
% unfortunately, the python script does not work, so here I fake some data
% for developing the rest of the pipeline.
% fake some coordinate data
xfake = 1000*randn([length(all_eleinf),1]);
yfake = 1000*randn([length(all_eleinf),1]);
for t = 1: length(all_eleinf)
    all_eleinf(t).coor_1 = xfake(t);
    all_eleinf(t).coor_2 = yfake(t); 
end

xfake = 1000*randn([length(small_eleinf),1]);
yfake = 1000*randn([length(small_eleinf),1]);
for t = 1: length(small_eleinf)
    small_eleinf(t).coor_1 = xfake(t);
    small_eleinf(t).coor_2 = yfake(t); 
end





%(((+_+)))generate stimuli !!!

%1 generate stimuli CONs
Bird.findcandidates
%Use autoSegmenter to segment songs
% and load the mergedeleinf



% this is not good, it is necessary to concatenate con_eleinf with
% all_eleinf
% !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
% here the con_eleinf should come from all_eleinf
xfake = 1000*randn([length(conspe_sylinf),1]);
yfake = 1000*randn([length(conspe_sylinf),1]);
for t = 1: length(conspe_sylinf)
    conspe_sylinf(t).coor_1 = xfake(t);
    conspe_sylinf(t).coor_2 = yfake(t); 
end



conS = stimuli(conspe_sylinf);
conS.setoutdir("E:\Total_stimuli_Y687");
conS.writenorm;




%2 generate stimuli degressives
allsongnames = [conspe_sylinf.songname].';
songnames = unique(allsongnames);

for v = 1: length(songnames)
    this_song_ids = find(~cellfun(@isempty, regexp(songnames{v},allsongnames)));
    this_song_inf = conspe_sylinf(this_song_ids);
    degS = stimuli(this_song_inf);
    degS.setoutdir("E:\Total_stimuli_Y687");
    degS.writedegressive; % write degressive songs
end

%3 generate stimuli catego replacement, single syllables


con_ids = find(~cellfun(@isempty,regexp([all_eleinf(:).songname].','CON|SPE'))); % ids of CON/SPE songs in all_eleinf
ss = stimuli(all_eleinf);
%ss = stimuli(test_inf);
ss.setoutdir("E:\Total_stimuli_Y687");
first_ids = find([ss.prepro.fragid].' == 1);
ss.writeFrag_far_from_all;
ss.writeFrag_far_from_senatus;
for m = 1: 10 % for each element of CONs, generate the corresponding stimuli
    
    disp(m); 
    ss.writeFrag_near_from_all(m);
    ss.writeFrag_near_from_senatus(m);
    
    
    ss.writeRepla_far_from_all(m);
    ss.writeRepla_far_from_senatus(m);
    
        
    if ~ismember(m,first_ids)
        ss.writeRepla_near_from_all(m);
        ss.writeRepla_near_from_senatus(m);
    else
    end
    
   
    disp('雨打风吹去');
end

ss.draw_stimuli_space(5)

ss.draw_stimuli_space(20)

ss.draw_stimuli_space(60)
ss.draw_stimuli_space(90)
% sort the data , then

%read the plx file to analyze the data 

  b = Batch(path_txt,path_plx,path_stimuli);
    b.select;
    neuronlist = b.getn;
    
    for k = 1: length(neuronlist)
        thisn = neuronlist{k};
        %thisn.rawthree;
        thisn.back_analysis_spectral_space;
    end


%%% process the data

% part- 1 to draw the spectrogram in the spectral space



figure
set(gca,'Color','k')
hold on
for w = 1: 100
    img = Cal.spec(all_eleinf(w).y,all_eleinf(w).fs);
%     figure
%     Draw.spec(all_eleinf(w).y,all_eleinf(w).fs);
    try
        if length(all_eleinf(w).y)  > 600
            subimage(all_eleinf(w).xfake,all_eleinf(w).yfake,img);
            colormap('jet')
            %scatter(all_eleinf(w).xfake,all_eleinf(w).yfake);
            drawnow
        end
    catch error
    end
    
end

axis([min(xfake) max(xfake) min(yfake) min(yfake)])
axis equal




% find out the cloest element in eleinf !!!
 coordinate = [all_eleinf.xfake; all_eleinf.yfake].';
 
 % set the candidate coor as 15 ,but this is just a very basic trial
 
 distance = [];
 
 for a = 1: length(coordinate)
 distance(a) = norm(coordinate(a,:) - coordinate(15,:))
 end
 
 [distance,restored] = sort(distance);
 sorted_coor = coordinate(restored,:);
 cloest = sorted_coor(2:11,:);
 
 %try to verift this part
 
 figure;
 scatter(coordinate(:,1),coordinate(:,2));
 hold on
 scatter(cloest(:,1),cloest(:,2));
 

% analayze the data to show the binary response !!!



