% Scratch 30 This a scratch to show all the steps necessary for generating
% stimuli, and analye the neural response to the stimuli

%(((^>^))) This section is for fitering bucket folders, only select those
%good folders
% dbstop if error
% fs = 32000;
% b = Bird("Z:\Yazaki-SugiyamaU\Bird-song"); % bi is the Bird object
% b.rand % randomize the folder paths
% goodfolders = b.folders;
ConDirs = fromWavFindParentFolder("C:\Users\Zhehao\Dropbox (OIST)\My_Stimuli\O684@test@20211019","E:\WavsCollection");
%Confolders = ConDirs; % Overwrite goodfolders

%To place confolders at the front
%[Lia,locb] = ismember([Confolders{:}].',[goodfolders(:)]);
% new_ids = vertcat(locb(locb>0),setdiff([1: length(goodfolders)],locb(locb>0)).'); %v new ids which place ConFolders in the front
% goodfolders = goodfolders(new_ids).';
% 
% 
% %(((^_^))) This section is for copy .wav files from bucket to my PC, and
% %this will be applied for each bird
% 
%  build = buildFraginf("E:\SyllableCollections");
%  
% tic
% for f = 1: length(goodfolders)
%    
%     build.moveFromBucket(goodfolders{f}); % blue137 (f = 25)contains too many files !!!
%     fprintf('Number __%u__ in %u folders\n',f,length(goodfolders));
%     disp('草如劍形，上有七星，列如北斗');
% end
% toc
% 
% 
% %(((^~^))) This section is for segmenting copied songs into syllables. 
 wav_dir = "E:\WavsCollection";
% %wav_dir = "E:\Fake_Try";
 subdirs = extract.folder(wav_dir);
 [Lia,locb] = ismember([ConDirs{:}].',[subdirs{:}].');
% tic
% for r = 1:length(subdirs)
%     
% %    if ~isempty(extract.filename(sprintf('%s\\SegData',subdirs{r}),'*.mat'))
% %        continue % if already segmented, do not segment again!!!
% %    end
%    
%    as = autoseg(subdirs{r});
%    as.intoSyllables_restrict_bout(5); % restrict to five bout
%     
%     fprintf('Now__%u__of %u dirs are processed',r,length(subdirs));
% end
% toc


% send_mail_message('379380788@qq.com','First section finished','Oops')


%(((^~^))) Convert segdata files into eleinf, and then convert eleinf into
%the format suitable for the python script


noncon_dir_whole_collection = subdirs(setdiff([1: length(subdirs)],locb(locb>0)).');
noncon_ote_eleinf = buildFraginf.assemble_as_sylinf(noncon_dir_whole_collection ,300,'SegData'); % 300 means remove folderes with bird id smaller than 300
ote_eleinf = categoFrags(noncon_ote_eleinf).eachsong;
unique_ote_eleinf = stimuli.unique_it( ote_eleinf );
% remove too long or too short elements
for k = 1: length(unique_ote_eleinf )
    unique_ote_eleinf(k).len = length(unique_ote_eleinf (k).y);
end

%T_unique_ote_eleinf = struct2table(unique_ote_eleinf);
rm_eleinf = unique_ote_eleinf(find(8000 >[unique_ote_eleinf.len].'& [unique_ote_eleinf.len].'> 800));
%split ote_eleinf to non-con and con eleinf

% 这里的目的是为了让con-ELEINF的运算流程和ote-eleinf的运算流程一样
as = autoseg("E:\Selected_wavs");
 as.intoSyllables;
readed_coneleinf = buildFraginf.assemble_as_sylinf("E:\Selected_wavs" ,300,'SegData')
%    as.intoSyllables_restrict_bout
conspe_eleinf = autoseg("C:\Users\Zhehao\Dropbox (OIST)\My_Stimuli\Y687@10252021").singleSegmenterSyl;
con_dir_in_whole_collection = subdirs(locb(locb>0));
con_ote_eleinf = buildFraginf.assemble_as_sylinf(con_dir_in_whole_collection ,300,'SegData');
con_plus_conrelated_ote_eleinf = categoFrags(con_ote_eleinf).include_con(conspe_eleinf); % add catego info into the eleinf

S = stimuli(con_plus_conrelated_ote_eleinf);

TT = struct2table(con_plus_conrelated_ote_eleinf);
% temp_con = conspe_eleinf;
% for k = 1: length(temp_con)
%     temp_con(k).len = length(temp_con(k).y);
% end 
% cont = struct2table(temp_con); % Here I should find the max and min length of eleinf!!!






% % to further remove eles which have the same name with con_eleinf
% ConDirs = fromWavFindParentFolder("C:\Users\Zhehao\Dropbox (OIST)\My_Stimuli\Y687@10252021").';
% con_spe_names = {};
% for zeno = 1: length(ConDirs)
%    splitted = split( ConDirs{zeno},'\');
%    con_spe_names{zeno} = splitted{end};
% end
% 
% pure_songname = {};
% for ee = 1: length(rm_eleinf)
%     temp = rm_eleinf(ee).songname;
%     temp = split(temp,'-');
%     pure_songname{ee} = temp{end};
% end
% Lia = find(~ismember(pure_songname,con_spe_names));
% rm2_eleinf = rm_eleinf(Lia); % fuether filtere eleinf
% 
% con_eleinf = conspe_eleinf(find(cellfun(@isempty,regexp([conspe_eleinf.songname].','Mcall|Het|Fcall|WNS'))));

all_eleinf = horzcat(con_plus_conrelated_ote_eleinf,rm_eleinf);
for p = 1: length(all_eleinf)
    all_eleinf(p).uniqueid = p;
end

preprocessVrae(all_eleinf); % this code will write labeled_eleConOnly.mat

% Here I should load the coor_Z trained by the neural network
for p = 1: length(all_eleinf)
    all_eleinf(p).coor_1 = coor_Z(p,1);
    all_eleinf(p).coor_2 = coor_Z(p,2);
end



%(((@_@)))Then load eleinf generated by python code -VRAE
% unfortunately, the python script does not work, so here I fake some data
% for developing the rest of the pipeline.
% fake some coordinate data
xfake = 1000*randn([length(all_eleinf),1]);
yfake = 1000*randn([length(all_eleinf),1]);
for t = 1: length(all_eleinf)
    all_eleinf(t).coor_1 = xfake(t);
    all_eleinf(t).coor_2 = yfake(t); 
end

xfake = 1000*randn([length(small_eleinf),1]);
yfake = 1000*randn([length(small_eleinf),1]);
for t = 1: length(small_eleinf)
    small_eleinf(t).coor_1 = xfake(t);
    small_eleinf(t).coor_2 = yfake(t); 
end





%(((+_+)))generate stimuli !!!

%1 generate stimuli CONs
Bird.findcandidates
%Use autoSegmenter to segment songs
% and load the mergedeleinf



% this is not good, it is necessary to concatenate con_eleinf with
% all_eleinf
% !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
% here the con_eleinf should come from all_eleinf
xfake = 1000*randn([length(conspe_eleinf),1]);
yfake = 1000*randn([length(conspe_eleinf),1]);
for t = 1: length(conspe_eleinf)
    conspe_eleinf(t).coor_1 = xfake(t);
    conspe_eleinf(t).coor_2 = yfake(t); 
end



conS = stimuli(conspe_eleinf);
conS.setoutdir("E:\Total_stimuli_Y687");
conS.writenorm;




%2 generate stimuli degressives
allsongnames = [conspe_eleinf.songname].';
songnames = unique(allsongnames);

for v = 1: length(songnames)
    this_song_ids = find(~cellfun(@isempty, regexp(songnames{v},allsongnames)));
    this_song_inf = conspe_eleinf(this_song_ids);
    degS = stimuli(this_song_inf);
    degS.setoutdir("E:\Total_stimuli_Y687");
    degS.writedegressive; % write degressive songs
end

%3 generate stimuli catego replacement, single syllables


con_ids = find(~cellfun(@isempty,regexp([all_eleinf(:).songname].','CON|SPE'))); % ids of CON/SPE songs in all_eleinf
ss = stimuli(all_eleinf);
%ss = stimuli(test_inf);
ss.setoutdir("E:\Total_stimuli_Y687");
first_ids = find([ss.prepro.fragid].' == 1);
ss.writeFrag_far_from_all;
ss.writeFrag_far_from_senatus;
for m = 1: 10 % for each element of CONs, generate the corresponding stimuli
    
    disp(m); 
    ss.writeFrag_near_from_all(m);
    ss.writeFrag_near_from_senatus(m);
    
    
    ss.writeRepla_far_from_all(m);
    ss.writeRepla_far_from_senatus(m);
    
        
    if ~ismember(m,first_ids)
        ss.writeRepla_near_from_all(m);
        ss.writeRepla_near_from_senatus(m);
    else
    end
    
   
    disp('雨打风吹去');
end

ss.draw_stimuli_space(5)

ss.draw_stimuli_space(20)

ss.draw_stimuli_space(60)
ss.draw_stimuli_space(90)
% sort the data , then

%read the plx file to analyze the data 

  b = Batch(path_txt,path_plx,path_stimuli);
    b.select;
    neuronlist = b.getn;
    
    for k = 1: length(neuronlist)
        thisn = neuronlist{k};
        %thisn.rawthree;
        thisn.back_analysis_spectral_space;
    end


%%% process the data

% part- 1 to draw the spectrogram in the spectral space



figure
set(gca,'Color','k')
hold on
for w = 1: 100
    img = cal.spec(all_eleinf(w).y,all_eleinf(w).fs);
%     figure
%     draw.spec(all_eleinf(w).y,all_eleinf(w).fs);
    try
        if length(all_eleinf(w).y)  > 600
            subimage(all_eleinf(w).xfake,all_eleinf(w).yfake,img);
            colormap('jet')
            %scatter(all_eleinf(w).xfake,all_eleinf(w).yfake);
            drawnow
        end
    catch error
    end
    
end

axis([min(xfake) max(xfake) min(yfake) min(yfake)])
axis equal




% find out the cloest element in eleinf !!!
 coordinate = [all_eleinf.xfake; all_eleinf.yfake].';
 
 % set the candidate coor as 15 ,but this is just a very basic trial
 
 distance = [];
 
 for a = 1: length(coordinate)
 distance(a) = norm(coordinate(a,:) - coordinate(15,:))
 end
 
 [distance,restored] = sort(distance);
 sorted_coor = coordinate(restored,:);
 cloest = sorted_coor(2:11,:);
 
 %try to verift this part
 
 figure;
 scatter(coordinate(:,1),coordinate(:,2));
 hold on
 scatter(cloest(:,1),cloest(:,2));
 

% analayze the data to show the binary response !!!



