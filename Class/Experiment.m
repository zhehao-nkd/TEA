 classdef Experiment < handle
 
    properties
        e
        plxname
        channelname
        unitname
        channelunit
        neuronname
        slist % sound list
        lieshu
        hangshu
        mergedeleinf
        waveform
        wavepc
        wavepeak
        wavevalley
        wavetimes
        sameChannelSpikes % Spikes info from the same channel
        signalGoodness
        plx_data_fs
        uniqueid
        birdid
        unique_neuronname
        e_of_songs %  对标 e
        slist_of_songs% 对标 slist
        mergeIdx % the idx for identifying which section of the merged plexonfiles
        
        Fid % F01 or F02 etc.
        blank
        
        insonglist
        figsize
        
        spikes % 原始输入
        plxdata % 原始输入
        folder_wav % 原始输入
        
    end
    
    methods % 内部计算方法
        
        function exp = Experiment(spikes, plxdata, folder_wav) % plxdata可以是path或Trigger
            
            dbstop if error
            if nargin == 0 % No input,then create a null object
                return;
            end
            
            exp.spikes = spikes;
            exp.plxdata = plxdata;
            exp.folder_wav = folder_wav;
            
            % 获取 Trigger Spike 这两种信息
            if strcmp(class(plxdata) ,'string')||strcmp(class(plxdata) ,'char') %如果喂的是path
                t = Trigger(plxdata);
                [~,exp.plxname,~] = fileparts(plxdata);
            elseif strcmp(class(plxdata) ,'Trigger') %如果喂的是处理后的Trigger Signal
                t = plxdata;
                [~,exp.plxname,~] = fileparts(t.inputpath);
            end
            temp1 = unique(spikes.channelname);
            exp.channelname = temp1{1};
            exp.unitname= unique(spikes.unit);
            exp.channelunit = strjoin({exp.channelname,num2str(exp.unitname)},'_');
            
            exp.neuronname = sprintf('%s_%s_%u',exp.plxname,exp.channelname,exp.unitname);
            sp = Spike(spikes); % here the neuron is a separatedT generated by spike.split
            sp.set_ephys_fs(t.trigger_fs); % set sampling rate of ephys signal
            
            % 获取与waveform有关的信息
            exp.waveform = sp.waveform;
            exp.wavepc = sp.pc;
            exp.wavepeak = sp.peak;
            exp.wavevalley = sp.valley;
            exp.wavetimes = sp.time; % timestamps
            
            % 获取与Songs有关的信息，并判断每个song folder所采用的trigger编码方式是二进制还是十进制
            if strcmp(class(folder_wav),'string')
            elseif strcmp(class(folder_wav),'char')
                folder_wav = convertCharsToStrings(folder_wav);
            end
            
            e_collector = {};
            for fd = 1: length(folder_wav)
                songpath = Sound.Extract(folder_wav(fd));
                difftype = [];
                folder_coding_method = 1; % 否则编码是十进制
                
                for k = 1: length(songpath)
                    difftype(k) = Sound(songpath{k}).getPulseDiffType;
                    if ismember(2, difftype) % 如果存在任何一个声文件，它的trigger信道方波间隔种类大于1
                        folder_coding_method = 2; % 2 means binary code，表明该folder使用二进制编码
                        break
                    end
                end
                
                sub_e = {};
                for k = 1: length(songpath)   %%% should be parfor!!!!!!!!!!
                    sound = Sound(songpath{k},folder_coding_method);
                    sub_e{k} = Piece(sp,t,sound);
                end
                e_collector{fd} = sub_e; % 收集此song folder所对应的ephys object
            end
            
            exp.e = horzcat(e_collector{:}); % merge所有的e together
            exp.gets;
            
            
            exp.lieshu = 12;
            temp = regexp(exp.plxname,'[RBOYRG]\d{3}','match');
            if ~isempty(temp)
                exp.birdid = temp{1};
            else
                exp.birdid = exp.plxname;
            end
            
            exp.figsize = PM.size3plots;
            temp = regexp(exp.plxname,'(?<=[ZP]\d+)F\d+','match');
            if ~isempty(temp)
                exp.Fid = temp{1};
            end
            
        end
        
        function exp = shiftNeuron(exp,spikes, path_plx, folder_wav,shift_value)
            % 纠正Zeus仪器的错误
            dbstop if error
            
            
            %             for m = 1: length(neurons) % for each neuron
            %                 sp = Spike(neurons{m});
            %
            %                 temp = struct;
            %                 parfor exp = 1: length(songs)
            %                     so = Sound(songs{exp});
            %                     temp(exp).e = Ephys2(sp,t,so);
            %                 end
            %                 temp2 = [temp.e];
            %             end
            
            songs = Sound.Extract(folder_wav);
            
            if exist('mergeIdx','var')
                exp.mergeIdx = mergeIdx;
            end
            
            
            t = Trigger.shiftTrigger(path_plx,shift_value);
            
            temp1 = unique(spikes.channelname);
            exp.channelname = temp1{1};
            exp.unitname= unique(spikes.unit);
            
            
            [~,exp.plxname,~] = fileparts(path_plx);
            exp.neuronname = sprintf('%s_%s_%u',exp.plxname,exp.channelname,exp.unitname);
            
            % for this neuron
            sp = Spike(spikes); % here the neuron is a separatedT generated by spike.split
            
            % get waveform
            exp.waveform = sp.waveform;
            exp.wavepc = sp.pc;
            exp.wavepeak = sp.peak;
            exp.wavevalley = sp.valley;
            exp.wavetimes = sp.time; % timestamps
            
            sp.set_ephys_fs(t.trigger_fs); % set sampling rate of ephys signal
            
            %sp.cal_wavelength？》？？？？？？？？？ calculate wavelength
            
            % Newley added bug fixer!!!!! 2022.02.15 To judge whether the
            % stimuli set is using binary coding or direct coding
            difftype = [];
            global_coding_method = 1;
            for k = 1: length(songs)
                % Here is a restriction, only pure direct code will be
                % regarded as direct coding. Even a single binary code will
                % lead to the whoel stimuli set be regarded as binary code
                difftype(k) = Sound(songs{k}).getPulseDiffType;
                if ismember(2, difftype)
                    global_coding_method = 2; % 2 means binary code
                    break
                end
                
                
            end
            
            
            
            for k = 1: length(songs)   %%% should be parfor!!!!!!!!!!
                if k == 42
                    disp('temp checkpoint!');
                end
                sound = Sound(songs{k},global_coding_method);
                e{k} = Piece(sp,t,sound);
                
            end
            exp.e = e;  % maybe because the connection to the bucket is dead
            
            exp.gets; % get a list of all songs
            
            
            exp.lieshu = 12;
            % exp.hangshu = ceil(length(exp.e)/exp.lieshu);
            
            %             if isempty( find(~cellfun(@isempty, regexp([exp.slist(:).name].','deg')) ) % if no deg stimuli
            %                 exp.fix_segmentation;  % replace the initials/terminals using those from exported .mat file
            %                 exp.find_ele_elicit_response;
            %             end
            
            temp = regexp(exp.plxname,'[RBOYRG]\d{3}','match');
            if ~isempty(temp)
                exp.birdid = temp{1};
            else
                exp.birdid = exp.plxname;
            end
            %exp.unique_neuronname = sprintf('%s_%u',exp.birdid,exp.uniqueid);
            
            
            
            
            
        end
        
        function exp = set_uniqueid(exp,unique_id)
            exp.uniqueid = unique_id;
            exp.unique_neuronname = sprintf('%s_%u',exp.birdid,exp.uniqueid);
        end
        
        function exp = gets(exp) % get sound list
            for idx = 1: length(exp.e)
                exp.slist(idx).idx = idx;
                exp.slist(idx).name = exp.e{idx}.sound.name;
            end
            exp.slist = exp.slist';
        end
        
        function exp = setEachStimuliSapFeatures(exp,sorted_data)% allocate sap features for each stimuli

            disp('Be careful if you have ever changed the names of stimuli files!!!! You have to re-generate sap jsons');
            for k = 1: length(exp.e)
                this_soundname = exp.e{k}.sound.name;
                fileid = find(~cellfun(@isempty, regexp({sorted_data.file_name}.' , this_soundname))); % If I compare only the pulse number, then it's okay to change the file names
                
                if isempty(fileid)
                    continue
                end
                % Generate raw features
                exp.e{k}.rawfeatures = sorted_data(fileid);% 初始化，不修改
                percentage_ini =  exp.e{k}.zpt*exp.e{k}.fs/length(exp.e{k}.rawy); % percentage for converting rawfeature to feature
                percentage_end = exp.e{k}.npt*exp.e{k}.fs/length(exp.e{k}.rawy);
                
                plt_per_ini = (exp.e{k}.zpt-exp.e{k}.pltext)*exp.e{k}.fs /length(exp.e{k}.rawy); % percentage for converting rawfeature to pltfeature
                plt_per_end = (exp.e{k}.npt+exp.e{k}.pltext)*exp.e{k}.fs /length(exp.e{k}.rawy);
                
                % Generate features
                exp.e{k}.features = sorted_data(fileid); % 初始化， 然后修改
                for ming = 1: length(fieldnames(exp.e{k}.features))
                    fnames = fieldnames(exp.e{k}.features);
                    values = exp.e{k}.features.( fnames{ming});
                    if isnumeric( values) && length(values)> 1
                        
                        new_ini_id = round(length(values)*percentage_ini); % 这里用round可能有问题
                        new_end_id = round(length(values)*percentage_end);
                        
                        if new_ini_id == 0
                            new_ini_id = 1; % in case 四舍五入到了0
                        end
                        
                        % replace the old values with the new values
                        exp.e{k}.features.( fnames{ming}) = values(new_ini_id:new_end_id);
                    end
                    
                end
                
%                 % Generate pltfeatures
%                 exp.e{k}.pltfeatures = sorted_data(fileid);% 初始化， 然后修改
%                 for qing = 1: length(fieldnames(exp.e{k}.pltfeatures))
%                     fnames = fieldnames(exp.e{k}.pltfeatures);
%                     values = exp.e{k}.pltfeatures.( fnames{qing});
%                     if isnumeric( values) && length(values)> 1
%                         
%                         new_ini_id = round(length(values)*plt_per_ini); % 这里用round可能有问题
%                         new_end_id = round(length(values)*plt_per_end);
%                         
%                         if new_ini_id == 0
%                             new_ini_id = 1; % in case 四舍五入到了0
%                             exp.e{k}.pltfeatures.( fnames{qing}) = values(new_ini_id:new_end_id);
%                         elseif new_ini_id < 0
%                             exceed  = abs(new_ini_id); % 溢出量
%                             values = [zeros(abs(exceed),1); values];
%                             exp.e{k}.pltfeatures.( fnames{qing}) = values(1:new_end_id + exceed);
%                             
%                         else % > 0
%                             
%                             % replace the old values with the new values
%                             
%                             exp.e{k}.pltfeatures.( fnames{qing}) = values(new_ini_id:new_end_id);
%                         end
%                     end   
%                 end
%                 
              
            end
        end
        
        function exp =  calMeanFeatures(exp) % based on features to calculate the mean features
            
            for k = 1: length(exp.e)
                
                if isempty(exp.e{k}.features)
                    continue
                end
                fnames = fieldnames(exp.e{k}.features);
                for m = 1: length(fnames)
                    values = exp.e{k}.features.( fnames{m});
                    
                    if isnumeric( values) && length(values)> 1
                        exp.e{k}.meanfeatures.( fnames{m}) = mean(values);
                    end
                end
                
            end
            
        end
        
    end
    
    methods(Access = private) % internal methods
        function sigsyllables = getIndexOfSigSyllable(exp)
            
            sigsyllables = struct;
            
            for k = 1: length(exp.e)
                sigsyllables(k).index = exp.e{k}.getIndexOfSigSyllable;
                sigsyllables(k).soundname =exp.e{k}.sound.name;
            end
        end
        
        function sigonly = siginf(exp)
            
            collect = cellfun(@(obj) obj.sigloc, exp.e,'UniformOutput',false);
            sigonly =  horzcat(collect{:});
            
        end
        
        function rank = picksongs(exp)
            img = three(exp);
            ax = gca;
            fig = ancestor(ax, 'figure');
            
            
            imshow(img)
            xlabel(ax,'Right click your mouse after labeling!') ;
            xs =[];
            ys = [];
            hold(ax, 'on');
            while true
                [x,y] = ginput(1);
                sel = get(fig, 'SelectionType');
                if strcmpi(sel, 'alt'); break; end
                scatter(x,y,100,'green');
                xs = [xs,x];
                ys = [ys,y];
            end
            hold(ax, 'off')
            
            [hei,wei,~] = size(img) % height and weight of the concatenated figure
            
            for f = 1: length(xs)
                lienum =  ceil(ys(f)/(hei/exp.hangshu))
                hangnum = ceil(xs(f)/(wei/exp.lieshu))
                rank(f) = (lienum - 1)*exp.lieshu + hangnum;
            end
            
            
            % get the figure size
            
        end
        
        function sylinf = sylinf(exp)
            
            %             collect = cellfun(@(obj) obj.sylinf, exp.e,'UniformOutput',false);
            %             sylinf =  horzcat(collect{:});
            
            tic;
            disp(sprintf('Current neuron is %s',exp.neuronname)); %#ok<DSPS>
            
            for idx = 1: length(exp.e)
                collect{idx} = exp.e{idx}.sylinf;
            end
            sylinf =  horzcat(collect{:});
            
            toc;
            newline;
            
        end
        
        function latency = cal_latency(exp) % to estimate latency of this neuron
            % But I am afraid that this function may not work very well
            latency_collect = []; % for summation and average of all the latency values
            counter = 0; % counter for the latency
            
            for q = 1: length(exp.e)
                if ismember(1,exp.e{q}.getIndexOfSigSyllable) % if 1 is the member : means when this neuron respond to the first element
                    
                    % here the sig function, as I read its calculation,
                    % is to find the nearest initial before peak location
                    % in time dimension
                    counter = counter + 1;
                    
                    [~,times] = exp.e{q}.getSigRespnse; % equals to the latency
                    
                    latency_collect(counter) = times(1);
                end
            end
            
            latency =  min(latency_collect);
            if isempty(latency)
                latency = 0; % default 0 ms
            end
            
        end
        
    end
    
    methods(Hidden)% deprecated methods
        % 弃用的方法
        function spikeinf = manspike(exp) % manually screen significant spike events
            num = 0;
            for idx = 1: length(exp.e)
                %fig = figure;
                
                %WindowAPI(fig, 'full');
                %fig.WindowState = 'maximized';
                exp.e{idx}.Three;
                set(gcf,'units','normalized','outerposition',[0 0 1 1])
                [x,y] = ginput;
                for kk = 1: length(x)
                    num = num + 1;
                    spikeinf(num).t = x(kk)-exp.e{idx}.pltext;  % spike time relative to the initial of the song
                    spikeinf(num).peak = y(kk); % spike peak
                    spikeinf(num).soundname = exp.e{idx}.sound.name;
                    spikeinf(num).neuronname = exp.neuronname;
                    
                end
                close(gcf);
            end
            
        end
        function sylinf = sapsylinf(exp)
            dbstop if error
            tic;
            disp(sprintf('Current neuron is %s',exp.neuronname)); %#ok<DSPS>
            
            for idx = 1: length(exp.e)
                collect{idx} = exp.e{idx}.sapsylinf;
            end
            sylinf =  horzcat(collect{:});
            
            toc;
            newline;
        end
        function siginf = sapsiginf(exp)
            sylinf = exp.sapsylinf;
            
            idx = find([sylinf.label].');
            siginf = sylinf(idx);
            
        end
        function sylT = sylinfsl(exp) % same length
            
            tic;
            disp(sprintf('Current neuron is %s',exp.neuronname)); %#ok<DSPS>
            parfor idx = 1: length(exp.e)
                collect{idx} = exp.e{idx}.sylinfq;
            end
            syl =  horzcat(collect{:}).';
            
            parfor idx = 1: length(syl)
                len(idx) = length(syl(idx).y);
            end
            syl(len>PM.SYLLEN) = []; % remove longer syllables
            
            parfor id = 1: length(syl)
                syl(id).y = Utl.pad(syl(id).y,PM.SYLLEN); % pad to 12800
                syl(id).image = Cal.img(syl(id).y,syl(id).fs); % store the image matrix
                temp = Extract.feature(syl(id).y,syl(id).fs);
                syl(id).goodness = temp.goodness;
                syl(id).meanf = temp.mean_frequency;
                syl(id).fm = temp.fm;
                syl(id).amplitude = temp.amplitude;
                syl(id).entropy = temp.entropy;
                syl(id).pitch = temp.pitch;
                syl(id).rawpitch = temp.rawpitch;
                syl(id).am = temp.AM;
                
                
            end
            sylT = struct2table(syl);
            newline;
            toc;
            
        end
        function sylT = sylinfsld(exp) % same length% downsample
            
            
            tic;
            disp(sprintf('Current neuron is %s',exp.neuronname)); %#ok<DSPS>
            parfor idx = 1: length(exp.e)
                collect{idx} = exp.e{idx}.sylinfq;
            end
            syl =  horzcat(collect{:}).';
            
            parfor idx = 1: length(syl)
                len(idx) = length(syl(idx).y);
            end
            syl(len> PM.SYLLEN) = []; % remove longer syllables
            
            parfor id = 1: length(syl)
                syl(id).y = Utl.pad(syl(id).y,PM.SYLLEN); % pad to 12800
                %syl(id).image = Cal.img(syl(id).y,syl(id).fs); % store the image matrix
                temp = Extract.feature(syl(id).y,syl(id).fs);
                drate = 3; % downsampling rate
                syl(id).goodness = downsample(temp.goodness,drate);
                syl(id).meanf = downsample(temp.mean_frequency,drate);
                syl(id).fm = downsample(temp.fm,drate);
                syl(id).amplitude = downsample(temp.amplitude,drate);
                syl(id).entropy = downsample(temp.entropy,drate);
                syl(id).pitch = downsample(temp.pitch,drate);
                %syl(id).rawpitch = downsample(temp.rawpitch,drate);
                syl(id).am = downsample(temp.AM,drate);
                
            end
            sylT = struct2table(syl);
            newline;
            toc;
            
        end
        function [e_songs,slist_songs] = onlyExtractEphysOfSongs(exp)
            
            song_only_ids =  find(~cellfun(@isempty, regexp(cellstr({exp.slist.name}.'),'norm')));
            
            e_songs = {exp.e{song_only_ids}};
            
            slist_songs = exp.slist(song_only_ids);
            
            % change the idx field of slist_songs
            for k = 1: length(slist_songs)
                slist_songs(k).idx = k;
            end
        end
        function latency = Deprecated_Old_version_cal_latency(exp) % to estimate latency of this neuron
            % But I am afraid that this function may not work very well
            latency_collect = []; % for summation and average of all the latency values
            y = 0; % counter for the latency
            
            for q = 1: length(exp.e)
                if ismember(1,exp.e{q}.sig) % if 1 is the member : means when this neuron respond to the first element
                    
                    % here the sig function, as I read its calculation,
                    % is to find the nearest initial before peak location
                    % in time dimension
                    y = y + 1;
                    latency_collect(y) = exp.e{q}.sigloc(1); % equals to the latency
                end
            end
            latency =  min(latency_collect);
            
        end
        function showsigspec(exp)
            siginf = exp.siginf;
            gap = zeros(0.05*32000,1);
            concatenated = gap;
            
            for idx = 1: length(siginf)
                concatenated = [concatenated;siginf(idx).y;gap];
            end
            figure('Color','w');
            Draw.spec(concatenated,32000);
        end
        function pre = preinf(exp)
            collect = cellfun(@(obj) obj.preinf, exp.e,'UniformOutput',false);
            pre =  horzcat(collect{:}).';
        end
        
        function Deprecated_drawInSongFragsMeanFeaturesVsRespAsLineChart(exp) % draw the distribution of mean features
            
            fraglist = exp.extractInfoOfResponseToWithinSongFrags
            if isempty(fraglist)
                return;
            end
            for k = 1: length(fraglist)
                fraglist(k).responseMeasure = fraglist(k).maxvalue;
            end
            
            toshow = struct;
            for u = 1: length(fraglist)
                toshow(u).amplitude = fraglist(u).mean_amplitude;
                toshow(u).pitch = fraglist(u).mean_pitch;
                toshow(u).AM = fraglist(u).mean_AM;
                toshow(u).mean_frequency = fraglist(u).mean_mean_frequency;
                toshow(u).FM = fraglist(u).mean_FM;
                toshow(u).peak_frequency = fraglist(u).mean_peak_frequency;
                toshow(u).entropy = fraglist(u).mean_entropy;
                toshow(u).resp = fraglist(u).responseMeasure;
            end
            
            toshow  = table2struct(sortrows(struct2table(toshow), 'resp','ascend'));
            
            
            num_toshow = [toshow.amplitude; toshow.pitch; toshow.AM; toshow.mean_frequency; toshow.FM; ...
                toshow.peak_frequency; toshow.entropy].';
            
            znum_toshow = zscore(num_toshow,0,1);
            %
            %            figure
            %            plot(znum_toshow.');
            
            figure('Position',[1997 233 1388 658],'Color','w');
            hold on
            c = 1- rescale([toshow.resp].',0.1,1); % rescale to 0.01-1 not 0 -1
            for r = 1: length(znum_toshow)
                plot(znum_toshow(r,:),'Color',repmat(c(r),3,1));
            end
            
            colormap(flip(repmat(unique(c),1,3)))
            colorbar
            xlim([0,8]);
            xticks([0 1 2 3 4 5 6 7 8])
            xticklabels({'','amplitude','pitch','AM','mean_frequency','FM','peak-frequency','entropy',''});
            title(sprintf('Totally %u song elements',length(fraglist)));
            ylabel('Zscored Feature(averaged)');
            
            saveas(gcf,sprintf('V2-InSongLineChartMeanFeaturesVsResp-%s.png',exp.unique_neuronname));
            close(gcf);
        end
        function syl = avgn(exp)
            %collect = cellfun(@(obj) obj.avgn, exp.e,'UniformOutput',false);
            % cellfun is slow
            tic;
            disp(sprintf('Current neuron is %s',exp.neuronname)); %#ok<DSPS>
            for idx = 1: length(exp.e)
                collect{idx} = exp.e{idx}.avgn;
            end
            syl =  horzcat(collect{:});
            
            
            newline;
            toc;
            
        end
        
        function prespec(exp) % draw the spectrogram of the pre-peak stimuli durations
            pre = exp.preinf;
            
            
            edges = [];
            sumy = [];
            thisedge = 0;
            for idx = 1: length(pre)
                sumy = [sumy;pre(idx).y];
                thisedge = thisedge + length(pre(idx).y);
                edges = [edges,thisedge];
            end
            figure;
            sumy(isnan(sumy))=0; % Convert nan to 0
            Draw.spec(sumy,pre(1).fs);
            
            for idx = 1: length(edges)
                xpair = repmat(edges(idx),2,1);
                ypair = [0,16];
                hold on
                line(xpair/pre(1).fs,ypair,'color','r');
            end
            
            %             figure;
            %             for idx = 1: length(pre)
            %                 subplot(length(pre),1,idx);
            %                 Draw.spec(pre(idx).y,pre(idx).fs);
            %                 xlabel('');
            %                 ylabel('');
            %                 set(gca,'xtick',[],'ytick',[])
            %                 set(gca,'xticklabel',[],'yticklabel',[])
            %             end
            
        end
        
        function collect = extractstimuli(exp)
            
            tic;
            disp(sprintf('Current neuron is %s',exp.neuronname)); %#ok<DSPS>
            parfor idx = 1: length(exp.e)
                %collect{idx} = exp.e{idx}.y;
                figure('Visible','off')
                Draw.spec(exp.e{idx}.y,exp.e{idx}.fs);
                temp = getframe(gcf);
                I = temp.cdata;
                collect{idx} = rgb2gray(I);
            end
            
            newline;
            toc;
        end
        
        function collect = extractsdf(exp)
            
            tic;
            disp(sprintf('Current neuron is %s',exp.neuronname)); %#ok<DSPS>
            parfor idx = 1: length(exp.e)
                collect{idx} = Cal.sdf(exp.e{idx}.sptimes,exp.e{idx}.y,exp.e{idx}.fs);
            end
            
            newline;
            toc;
        end
        
        function featuretsne(exp)
            dbstop if error
            outdir = 'feature_tsne';
            mkdir(outdir);
            syl = exp.sylinfsl;
            label =syl.label;
            idx = find(label);
            
            
            feature = {'am','fm','pitch','amplitude','meanf','goodness','entropy'};
            
            for f = 1: length(feature)
                tested = eval([ 'syl.',feature{f},';']);
                
                coordi = tsne(tested);
                if isempty(coordi)
                    continue
                end
                figure;
                scatter(coordi(:,1),coordi(:,2),[],[0.5 0.5 0.5],'filled');
                hold on
                
                labcoordi = coordi(idx,:);
                scatter(labcoordi(:,1),labcoordi(:,2),[],'b','filled');
                filename = sprintf('%s_%s',exp.neuronname,feature{f});
                
                xlabel( filename);
                hold off
                
                saveas(gcf,[outdir,'/',filename,'.png']);
                close(gcf)
            end
        end
        
        function trg = trg4nex(exp)
            k = 0;
            for idx = 1: length(exp.e)
                if ~isempty(exp.e{idx})
                    k = k + 1;
                    trgnum = exp.e{idx}.sound.trigger;
                    trg(k).name = exp.e{idx}.sound.name;
                    selected = find ([exp.e{idx}.trigger.info.name] == trgnum);
                    trg(k).tgime = exp.e{idx}.trigger.info(selected).time;
                    
                end
            end
            trg = trg';
            trgt = struct2table(trg);
            writetable(trgt, 'TRG_tocopy.csv','WriteRowNames',false,'WriteVariableNames',false)
        end
        function len = sylnum(exp)
            len = 0;
            for idx = 1: length(exp.e)
                len = len + exp.e{idx}.sylnum;
            end
        end
        
        function ssinfo = singlesylinf(exp)
            
            for h = 1: length(exp.e)
                thise = exp.e{h};
                ssinfo(h).plty = thise.plty;
                ssinfo(h).pltsptimes = thise.pltsptimes;
                ssinfo(h).sptimes = thise.sptimes;
                ssinfo(h).fs = thise.fs;
                ssinfo(h).name = thise.sound.name;
                temp = strsplit(thise.sound.name,'_');
                temp = temp{1};
                temp = strsplit(temp,'-');
                ssinfo(h).songname = temp{2};
                ssinfo(h).fragid = str2num(temp{3});
            end
            
            ssinfo = table2struct(sortrows(struct2table(ssinfo),{'songname','fragid'}));
            
        end
        
        function sapsigspec(exp)
            siginf = exp.sapsiginf;
            gap = zeros(0.05*32000,1);
            concatenated = gap;
            
            for idx = 1: length(siginf)
                concatenated = [concatenated;siginf(idx).y;gap];
            end
            figure('Color','w');
            Draw.spec(concatenated,32000);
            
        end
        
        function sapscatter(exp)  % function to generate scatter plot based on sapsylinf
            sapsylinf = exp.sapsylinf;
            idx = find ([sapsylinf.label] ==1);
            labeled = sapsylinf(idx);
            
            figure('Color','w','Position',[1946 -103 1178 1086]);
            scatter([sapsylinf.pitch].',[sapsylinf.fm].','k','filled');
            
            hold on
            
            scatter([labeled.pitch].',[labeled.fm].','r','filled');
            
            xlabel('Pitch');
            ylabel('FM');
            title(exp.neuronname);
            saveas(gcf,sprintf('Scatter-%s.png',exp.neuronname));
            pause(0.5)
            close(gcf);
        end
        
    end
    
    methods % 有外部输出的计算方法
        
    
 
      
        function thelist = toList(exp,whether_update_figure) % This is the API between class Neuron and class Experiment
            
            if ~exist('whether_update_figure','var')
                whether_update_figure = 0;
            end
            thelist = struct;
            for k = 1: length(exp.e)
                
                thelist(k).stimuliname = exp.e{k}.sound.name;
                
                thelist(k).fs = exp.e{k}.fs;
                
                thelist(k).plxname = exp.e{k}.trigger.plxname;
                thelist(k).channelname = exp.channelname;
                thelist(k).unitname = exp.e{k}.spike.unit;
                
                thelist(k).y = exp.e{k}.y;
                thelist(k).rawy = exp.e{k}.rawy;
                thelist(k).plty = exp.e{k}.plty;
                thelist(k).judgerespy = exp.e{k}.judgerespy;
                %info(k).prejudgerespy = exp.e{k}.prejudgerespy;
                thelist(k).sptimes = exp.e{k}.sptimes;
%                 if length(exp.e{k}.sptimes) > 10
%                     disp('error here: Experiment line 850');
%                 end
                thelist(k).rawsptimes = exp.e{k}.rawsptimes;
                thelist(k).pltsptimes = exp.e{k}.pltsptimes;
                thelist(k).judgerespsptimes = exp.e{k}.judgerespsptimes;
                thelist(k).prejudgerespsptimes = exp.e{k}.prejudgerespsptimes;
                thelist(k).presptimes = exp.e{k}.presptimes;
                thelist(k).zpt = exp.e{k}.zpt; % zero point time
                thelist(k).leny = length(thelist(k).y);
                thelist(k).pltext = exp.e{k}.pltext;
                
                thelist(k).features = exp.e{k}.features;
                thelist(k).rawfeatures = exp.e{k}.rawfeatures;
                thelist(k).pltfeatures = exp.e{k}.pltfeatures;
                thelist(k).meanfeatures = exp.e{k}.meanfeatures;
                thelist(k).Fid = exp.Fid;
                
%                 if whether_update_figure == 1
%                     exp.e{k}.pltthree(0);
%                     frame = getframe(gcf);
%                     close(gcf);
%                     thelist(k).image = frame.cdata;
%                     thelist(k).imagename = exp.e{k}.sound.name;
%                 end
                
            end       
        end
        
        function insonglist = toList_Insong(exp) % This is the API between class Neuron and class Experiment
            
            exp.fix_segmentation;
            
            frags_collect = {};
            
            for k = 1: length(exp.e)
                
                E = exp.e{k};
                leny = length(E.rawy);
                %namepart1 = regexp(E.sound.name,'CON|SPE|norm','match');
                namepart2 = regexp(E.sound.name,'([OBGRY]\d{3})|Het|Fcall|Mcall|WNS','match');
                namepart3 = regexp(E.sound.name,'BOS|TUT','match');
                if ~isempty(namepart3)
                  namepart2 = strcat(namepart2,namepart3); 
                end
               % nameparts = strcat(namepart1,"-",namepart2);
                frags = E.sound.fragment;
                features = E.rawfeatures;
                for kk = 1: length(frags)
                    frags(kk).name =  sprintf('%s-frag%02u',namepart2,kk);
                    frags(kk).leny = length(frags(kk).y);
                    frags(kk).fragnum = kk;
                    frags(kk).fs = E.fs;
                    frags(kk).plxname = E.trigger.plxname;
                    frags(kk).channelname = exp.channelname;
                    frags(kk).unitname = E.spike.unit;
                    frags(kk).sptimes = Extract.sptimes(E.rawsptimes,frags(kk).initial/frags(kk).fs,frags(kk).terminal/frags(kk).fs);
                    % amplitude
                    lenf = length(features.amplitude); % length of feature values
                    frags(kk).features.amplitude = features.amplitude(round(frags(kk).initial*frags(kk).fs/leny*lenf):round(frags(kk).terminal/leny*lenf));
                    frags(kk).meanfeatures.amplitude = mean(frags(kk).features.amplitude);
                    
                    %mean_freq_amp
                    lenf = length(features.mean_frequency_amp); % length of feature values
                    frags(kk).features.mean_frequency_amp = features.mean_frequency_amp(round(frags(kk).initial/leny*lenf):round(frags(kk).terminal/leny*lenf));
                    frags(kk).meanfeatures.mean_frequency_amp = mean(frags(kk).features.mean_frequency_amp);
                    
                    %pitch
                    lenf = length(features.pitch); % length of feature values
                    frags(kk).features.pitch = features.pitch(round(frags(kk).initial/leny*lenf):round(frags(kk).terminal/leny*lenf));
                    frags(kk).meanfeatures.pitch = mean(frags(kk).features.pitch);
                    
                    %mean_frequency
                    lenf = length(features.mean_frequency); % length of feature values
                    frags(kk).features.mean_frequency = features.mean_frequency(round(frags(kk).initial/leny*lenf):round(frags(kk).terminal/leny*lenf));
                    frags(kk).meanfeatures.mean_frequency = mean(frags(kk).features.mean_frequency);
                    
                    %FM
                    lenf = length(features.FM); % length of feature values
                    frags(kk).features.FM = features.FM(round(frags(kk).initial/leny*lenf):round(frags(kk).terminal/leny*lenf));
                    frags(kk).meanfeatures.FM = mean(frags(kk).features.FM);
                    
                    %AM
                    lenf = length(features.AM); % length of feature values
                    frags(kk).features.AM = features.AM(round(frags(kk).initial/leny*lenf):round(frags(kk).terminal/leny*lenf));
                    frags(kk).meanfeatures.AM = mean(frags(kk).features.AM);
                    
                    %goodness
                    lenf = length(features.goodness); % length of feature values
                    frags(kk).features.goodness = features.goodness(round(frags(kk).initial/leny*lenf):round(frags(kk).terminal/leny*lenf));
                    frags(kk).meanfeatures.goodness = mean(frags(kk).features.goodness);
                    
                    %entropy
                    lenf = length(features.entropy); % length of feature values
                    frags(kk).features.entropy = features.entropy(round(frags(kk).initial/leny*lenf):round(frags(kk).terminal/leny*lenf));
                    frags(kk).meanfeatures.entropy = mean(frags(kk).features.entropy);
                    
                    %peak_frequency
                    lenf = length(features.peak_frequency); % length of feature values
                    frags(kk).features.peak_frequency = features.peak_frequency(round(frags(kk).initial/leny*lenf):round(frags(kk).terminal/leny*lenf));
                    frags(kk).meanfeatures.peak_frequency = mean(frags(kk).features.peak_frequency);
                    
                    %continuity_t
                    lenf = length(features.continuity_t); % length of feature values
                    frags(kk).features.continuity_t = features.continuity_t(round(frags(kk).initial/leny*lenf):round(frags(kk).terminal/leny*lenf));
                    frags(kk).meanfeatures.continuity_t = mean(frags(kk).features.continuity_t);
                    
                    %continuity_f
                    lenf = length(features.continuity_f); % length of feature values
                    frags(kk).features.continuity_f = features.continuity_f(round(frags(kk).initial/leny*lenf):round(frags(kk).terminal/leny*lenf));
                    frags(kk).meanfeatures.continuity_f = mean(frags(kk).features.continuity_f);
                    
                    %harmratio
                    lenf = length(features.continuity_f); % length of feature values
                    frags(kk).features.continuity_f = features.continuity_f(round(frags(kk).initial/leny*lenf):round(frags(kk).terminal/leny*lenf));
                    frags(kk).meanfeatures.continuity_f = mean(frags(kk).features.continuity_f);
                end
                
                ids = E.getIndexOfSigSyllable;
                
                for trump = 1: length(frags)
                    frags(trump).label = 0;
                end
                if length(ids)== 1
                    frags(ids).label = 1;
                elseif length(ids)> 1
                    for i = 1: length(ids);frags(ids(i)).label = 1;end
                end
                frags_collect{k} = frags;
                
            end
            
            insonglist = horzcat(frags_collect{:});
            
            
            window_size = min([insonglist.leny].');
            for k = 1:length(insonglist)
                insonglist(k).features.harmratio = harmonicRatio(insonglist(k).y,insonglist(k).fs,'Window',hamming(window_size,"periodic"),...
                    'OverlapLength',round(window_size*2/3) );
                %此处为照顾很短的frag改动了window size， 但或许更好的方法是放弃很短frag的数据
                insonglist(k).meanfeatures.harmratio = mean(insonglist(k).features.harmratio);
            end
            
            
        end
        
       

    
        function fix_segmentation(exp) % to fix the segmentation of songs into elements
            
            %folders = Extract.folder("C:\Users\Zhehao\Dropbox (OIST)\My_Stimuli");
            
            %temp = regexp(exp.plxname,'[BRYOG]\d{3}','match');
            % birdid = temp{1};
            % if  ~isempty(find(~ cellfun(@isempty,regexp([folders{:}],birdid)))) % if folder is there
            
            %thatfolder = folders{find(~ cellfun(@isempty,regexp([folders{:}],birdid)))}; % corresponding folder of the bird
            %load(sprintf('%s\\mergedeleinf.mat',thatfolder));
            
            fraginf = MetaStimuli.getAllTwoMotifEleinf("E:\StimuliSource");
            
            for r = 1: length(exp.e)
                
                %parts = split(exp.e{r}.sound.name,'-'); % find all the norm
                %songs
                name_to_search = regexp(exp.e{r}.sound.name,'(?<=norm\S+)([OBGYRX]\d{3})?(Fcall|WNS|Mcall|Het)?','match');
                
                bostut = regexp(exp.e{r}.sound.name,'TUT|BOS','match');
                
                if isempty(bostut)
                    local_ids = find(~cellfun(@isempty,regexp([fraginf.songname].',char(name_to_search) )));
                else
                    local_ids = intersect(find(~cellfun(@isempty,regexp([fraginf.songname].',char(name_to_search) ))),...
                        find(~cellfun(@isempty,regexp([fraginf.songname].',char(bostut) ))));
                end
                zerobegin_mat = [fraginf(local_ids).initial ].'-fraginf(local_ids(1)).initial;
                zerobegin_mat_terminal = [fraginf(local_ids).terminal ].'-fraginf(local_ids(1)).initial;
                first_initial = exp.e{r}.sound.initial(1);
                
                exp.e{r}.sound.initial = first_initial + zerobegin_mat;
                exp.e{r}.sound.terminal = first_initial +  zerobegin_mat_terminal;
                exp.e{r}.sound.updatefragment_for_fixsegmentation;
            end
            %end
        end
        
        function find_ele_elicit_response(exp) % return the index of the element which trigger neural response
            
            latency = cal_latency(exp);
            
            for k = 1: length(exp.e)
                locs_of_this_song = exp.e{k}.sigloc; % time location of neural response peak of this stimuli
                
                if ~isempty(latency)
                    locs_of_this_song = locs_of_this_song - latency; %!!!!!!  - latency!~!!!
                end
                
                initials = ( exp.e{k}.sound.initial -exp.e{k}.sound.initial(1) )/exp.e{k}.fs; % normalize the initials
                plt_initials = ( exp.e{k}.sound.initial -exp.e{k}.sound.initial(1) )/exp.e{k}.fs + exp.e{k}.pltext;
                plt_terminals = ( exp.e{k}.sound.terminal -exp.e{k}.sound.initial(1) )/exp.e{k}.fs+ exp.e{k}.pltext;
                if ~isempty(locs_of_this_song)
                    
                    exp.e{k}.three
                    hold on
                    
                    % draw segmentation lines
                    
                    for p = 1: length(plt_initials)
                        xline(plt_initials(p),'Color','g');
                        xline(plt_terminals(p),'Color','y');
                    end
                    
                    
                    for v = 1:length(locs_of_this_song)
                        %figure;
                        subplot(3,1,3)
                        xline(locs_of_this_song(v)+  exp.e{k}.pltext);               % - latency!~!!!
                        ele_idx_of_this_song(v) = length(find(locs_of_this_song(v)>initials)); % return the idx of the significant syllables
                        disp(length(find(locs_of_this_song(v)>initials)));
                        exp.e{k}.eliciting_element_counting_whole = ele_idx_of_this_song; % modify the Piece-Object from outside
                        disp('标记1');
                    end
                end
                disp('标记2');
                close(gcf);
            end
            
        end
        
        function eleinf = recover_eleinf(exp) % recover the struct named eleinf from thr Experiment object
            dbstop if error
            % case 1: when wav file does not contain the segmenation info
            
            folders = Extract.folder("C:\Users\Zhehao\Dropbox (OIST)\My_Stimuli");
            temp = regexp(exp.plxname,'[BRYOG]\d{3}','match');
            birdid = temp{1};
            
            if  ~isempty(find(~ cellfun(@isempty,regexp([folders{:}],birdid))))
                thatfolder = folders{find(~ cellfun(@isempty,regexp([folders{:}],birdid)))}; % corresponding folder of the bird
                load(sprintf('%s\\mergedeleinf.mat',thatfolder));
            end
            
            
            % remove non-CON elements including BOS and also TUT
            ids_to_delete =  find( ~cellfun(@isempty,regexp([mergedeleinf(:).songname].','Fcall|Het|Mcall|WNS|BOS|TUT')) );
            
            % load and Convert coordinate 1 and 2
            mergedeleinf(ids_to_delete)= [];
            %              [~,encodezpath] = uigetfile;
            %               load(encodezpath);
            
            load("C:\Users\Zhehao\Dropbox (OIST)\My_Stimuli\SourceSongSet1@06232021\vrae_birdsong_data.mat");
            
            for x = 1: length(mergedeleinf)
                mergedeleinf(x).coor_1 = Z_embedded(x,1);
                mergedeleinf(x).coor_2 = Z_embedded(x,2);
            end
            
            eleciting_info = extract_eleciting_info(exp);  % get the index of response-eliciting element
            
            for k = 1: length(exp.e)
                % SAVE THE SPEC AND ALSO THE RASTER DATA
                
                temp = split(exp.e{k}.sound.name,'-');
                temp = temp{2};
                
                this_ids = find(~cellfun(@isempty, regexp([mergedeleinf(:).songname].',temp)));
                
                specimg = Cal.spec(exp.e{k}.rawy,exp.e{k}.fs);
                x      = 0;   % Screen position
                y      = 0;   % Screen position
                width  = size(specimg,2); % Width of figure
                height = size(specimg,1); % Height of figure (by default in pixels)
                
                %rasterfig = figure( 'Position', [x y 2974 2974*height/width], 'Visible', 'off');
                rasterfig = figure( 'Position', [x y 2974 200], 'Visible', 'off');
                %figure
                box off
                set(gca, 'Visible', 'off')
                Draw.raster(exp.e{k}.rawsptimes,exp.e{k}.rawy,exp.e{k}.fs);
                F = getframe(rasterfig);
                [rasterimg, ~] = frame2im(F);
                rasterimg = imbinarize(rasterimg);
                % figure; imshow(rasterimg)
                EXTENSION = 0.060; % 60 ms exntension
                for cao = 1:  length(this_ids)
                    ini_percentage = (mergedeleinf(this_ids(cao)).initial-mergedeleinf(this_ids(1)).initial + exp.e{k}.sound.initial(1)) /length(exp.e{k}.rawy);
                    ter_percentage = (mergedeleinf(this_ids(cao)).terminal-mergedeleinf(this_ids(1)).initial + exp.e{k}.sound.initial(1) + EXTENSION*exp.e{k}.fs) /length(exp.e{k}.rawy);
                    
                    mergedeleinf( this_ids(cao)).rawspec = specimg(:,size(specimg,2)*ini_percentage:size(specimg,2)*ter_percentage);
                    mergedeleinf( this_ids(cao)).rawraster = rasterimg(:,size(rasterimg,2)*ini_percentage:size(rasterimg,2)*ter_percentage);
                    % figure; imshow(mergedeleinf( this_ids(cao)).rawspec)
                    % figure; imshow(mergedeleinf( this_ids(cao)).rawraster)
                end
            end
            
            
            
            
            % initiate wholecountsiglabel as 0
            for cnm = 1: length(mergedeleinf)
                mergedeleinf(cnm).wholecountsiglabel = 0;
            end
            
            for y = 1: length(eleciting_info)
                
                if ~isempty( eleciting_info(y).eleciting)
                    
                    samesongids =  find(~cellfun(@isempty, regexp([mergedeleinf(:).songname].',eleciting_info(y).name)));
                    for z = 1: length(eleciting_info(y).eleciting)
                        samefrgids = find(arrayfun(@(s) ismember(s,eleciting_info(y).eleciting), [mergedeleinf(:).fragid].' ));
                        ids_to_label = intersect(samesongids,samefrgids);
                        for wtf = 1: length(ids_to_label)
                            mergedeleinf(ids_to_label(wtf)).wholecountsiglabel = 1;
                        end
                    end
                end
            end
            
            eleinf = mergedeleinf;
            % case 2: when wav file contain the segmentation info
            
        end
        
        function add_spec_raster_info_2_eleinf(exp)
            
            mergedeleinf = exp.mergedeleinf;
            eleciting_info = extract_eleciting_info(exp);  % get the index of response-eliciting element
            
            for k = 1: length(exp.e)
                % SAVE THE SPEC AND ALSO THE RASTER DATA
                
                temp = split(exp.e{k}.sound.name,'-');
                temp = temp{2};
                
                this_ids = find(~cellfun(@isempty, regexp([mergedeleinf(:).songname].',temp)));
                
                specimg = Cal.spec(exp.e{k}.rawy,exp.e{k}.fs);
                x      = 0;   % Screen position
                y      = 0;   % Screen position
                width  = size(specimg,2); % Width of figure
                height = size(specimg,1); % Height of figure (by default in pixels)
                
                %rasterfig = figure( 'Position', [x y 2974 2974*height/width], 'Visible', 'off');
                rasterfig = figure( 'Position', [x y 2974 200], 'Visible', 'off');
                %figure
                box off
                set(gca, 'Visible', 'off')
                Draw.raster(exp.e{k}.rawsptimes,exp.e{k}.rawy,exp.e{k}.fs);
                F = getframe(rasterfig);
                [rasterimg, ~] = frame2im(F);
                rasterimg = imbinarize(rasterimg);
                % figure; imshow(rasterimg)
                EXTENSION = 0.060; % 60 ms exntension
                for cao = 1:  length(this_ids)
                    %%%% something is wrong here, need to check !!!!!!!!!!!
                    %%%% 02.07.20222
                    ini_percentage = (mergedeleinf(this_ids(cao)).initial-mergedeleinf(this_ids(1)).initial + exp.e{k}.sound.initial(1)) /length(exp.e{k}.rawy);
                    ter_percentage = (mergedeleinf(this_ids(cao)).terminal-mergedeleinf(this_ids(1)).initial + exp.e{k}.sound.initial(1) + EXTENSION*exp.e{k}.fs) /length(exp.e{k}.rawy);
                    
                    temp = split(exp.e{k}.sound.name,'-');
                    typename = temp{2};
                    
                    if strcmp(typename, 'OTE')
                        mergedeleinf( this_ids(cao)).rawspec = specimg
                        mergedeleinf( this_ids(cao)).rawraster = rasterimg
                    else
                        mergedeleinf( this_ids(cao)).rawspec = specimg(:,size(specimg,2)*ini_percentage:size(specimg,2)*ter_percentage);
                        mergedeleinf( this_ids(cao)).rawraster = rasterimg(:,size(rasterimg,2)*ini_percentage:size(rasterimg,2)*ter_percentage);
                        % figure; imshow(mergedeleinf( this_ids(cao)).rawspec)
                        % figure; imshow(mergedeleinf( this_ids(cao)).rawraster)
                    end
                end
            end
            
            % initiate wholecountsiglabel as 0
            for cnm = 1: length(mergedeleinf)
                mergedeleinf(cnm).wholecountsiglabel = 0;
            end
            
            for y = 1: length(eleciting_info)
                
                if ~isempty( eleciting_info(y).eleciting)
                    
                    samesongids =  find(~cellfun(@isempty, regexp([mergedeleinf(:).songname].',eleciting_info(y).name)));
                    for z = 1: length(eleciting_info(y).eleciting)
                        samefrgids = find(arrayfun(@(s) ismember(s,eleciting_info(y).eleciting), [mergedeleinf(:).fragid].' ));
                        ids_to_label = intersect(samesongids,samefrgids);
                        for wtf = 1: length(ids_to_label)
                            mergedeleinf(ids_to_label(wtf)).wholecountsiglabel = 1;
                        end
                    end
                end
            end
            
            exp.mergedeleinf = mergedeleinf;
            
        end
        
        function eleciting_info = extract_eleciting_info(exp) % Extract information of response-eleciting element from Piece objects
            
            eleciting_info = struct;
            
            for w = 1: length(exp.e)
                %temp = regexp(exp.e{w}.sound.name,'[BRYOG]\d{3}','match');
                temp = split(exp.e{w}.sound.name,'-');
                eleciting_info(w).name = temp{2};
                eleciting_info(w).eleciting = exp.e{w}.eliciting_element_counting_whole;
            end
        end
        
        function spec_space = back_analysis_spectral_space(exp)
            
            if isempty(exp.mergedeleinf)
                mergedeleinf = recover_eleinf(exp);
                exp.mergedeleinf = mergedeleinf;
            end
            eleinf = exp.mergedeleinf;
            figure;
            hold on
            
            if isfield(eleinf,'wholecountsiglabel')
                for f = 1: length(eleinf)
                    
                    if eleinf(f).wholecountsiglabel == 1
                        scatter(eleinf(f).coor_1,eleinf(f).coor_2,[],'r')
                    else
                        scatter(eleinf(f).coor_1,eleinf(f).coor_2,[],'b')
                    end
                end
            else
                for f = 1: length(eleinf)
                    scatter(eleinf(f).coor_1,eleinf(f).coor_2,[],'k');
                end
            end
            
            close(gcf)
            % draw spectrum in space
            cmap = jet;
            
            %           cmap = [0.2 0.1 0.5
            %               0.1 0.5 0.8
            %               0.2 0.7 0.6
            %               0.8 0.7 0.3
            %               0.9 1 0];
            %
            spec_space = figure
            set(gca,'Color','w')
            hold on
            axis([min([eleinf.coor_1]) max([eleinf.coor_1]) min([eleinf.coor_2]) max([eleinf.coor_2])])
            
            for w = 1: 100
                %               tempimg = Cal.spec(eleinf(w).y,eleinf (w).fs);
                %               tempimg = tempimg(80:250,:);
                tempspecimg = eleinf(w).rawspec;
                tempspecimg= tempspecimg(5:220,:);
                temprasterimg = eleinf(w).rawraster;
                temprasterimg = imresize(temprasterimg,size(tempspecimg));
                
                tempimg = vertcat(tempspecimg,temprasterimg);
                
                [alpha,beta] = size(tempimg);
                
                img = imresize(flip(tempimg,1),[alpha,beta*2]);
                
                [M,N] = size(img);
                block_size = 50;
                P = ceil(M / block_size);
                Q = ceil(N / block_size);
                alpha = checkerboard(block_size,  P, Q) > 0;
                alpha = alpha(1:M, 1:N);
                alpha = img;
                
                %     figure
                %     Draw.spec(all_eleinf(w).y,all_eleinf(w).fs);
                try
                    if length(eleinf(w).y)  > 50
                        
                        if eleinf(w).wholecountsiglabel == 0
                            
                            h = subimage(eleinf(w).coor_1*200,eleinf(w).coor_2*200,img*1);
                            set(h, 'AlphaData', 0.7);
                        elseif eleinf(w).wholecountsiglabel == 1
                            
                            h = subimage(eleinf(w).coor_1*200,eleinf(w).coor_2*200,img*10,cmap(1:12:end,:));
                            set(h, 'AlphaData', 0.7);
                        end
                        %colormap(ax,'jet')
                        %scatter(all_eleinf(w).xfake,all_eleinf(w).yfake);
                        drawnow
                    end
                catch error
                end
                
            end
            
            % axis([min([eleinf.coor_1]) max([eleinf.coor_1]) min([eleinf.coor_2]) max([eleinf.coor_2])])
            %
            
        end
        
        function update_catego_for_each(exp)
            coor_1 = [exp.mergedeleinf.coor_1].'; coor_2 = [exp.mergedeleinf.coor_2].';
            coordinate = horzcat(coor_1,coor_2);
            
            distance = [];
            
            for indi = 1: length(coordinate)
                
                for a = 1: length(coordinate)
                    distance(a) = norm(coordinate(a,:) - coordinate(indi,:));
                end
                
                [B,I] = maxk(distance,10);
                
                
                cloest = coordinate(I,:);
                
                uni_id_cloest = [exp.mergedeleinf(I).fragid].';  % the unique id of element which is most cloest 10 element to current element
                exp.mergedeleinf(indi).closest10 = uni_id_cloest;
                %try to verift this part
                %
                %             figure;
                %             scatter(coordinate(:,1),coordinate(:,2));
                %             hold on
                %             scatter(cloest(:,1),cloest(:,2));
                
            end
            
        end
        
   
        
        function meanWL = calMeanWaveLength(exp) % Calculate mean wavelength
            
            waveforms =  exp.waveform;
            [~,troughstime] = min(waveforms,[],2);
            wavlen_units = [];
            
            for k = 1: size(waveforms,1) % length is dangerous!!!!!
                this_wf = waveforms(k,:);
                [~,wavlen_units(k)] =  max(this_wf (troughstime(k):end));
            end
            
            temp = regexp(exp.plxname,'[ZP]\d{2}F\d{1}','match');
            ZorP = regexp(temp,'[ZP]','match');
            if strcmp(ZorP,"Z")
                exp.plx_data_fs = 30000; %hard code !!!!!! Dangerous
            elseif strcmp(ZorP,"P")
                exp.plx_data_fs = 40000;
            end
            meanWL =  mean(wavlen_units*(1/exp.plx_data_fs)*1000); % ms
            
            
        end
        
        function draw_feature_distribution(exp,feature1,feature2) % to draw the distribuition of features used for spike sortings
            
            %default feature
            if ~exist('feature1','var')
                feature1 = 'pc1';
            end
            
            if ~exist('feature2','var')
                feature2 = 'pc2';
            end
            
            
            channelSpikes = table2struct( exp.sameChannelSpikes );
            
            same_unit_idx = find([channelSpikes.unit].' == exp.unitname);
            
            dim1_idx = find(~cellfun(@isempty, regexp([fieldnames(channelSpikes)].',feature1)));
            dim2_idx = find(~cellfun(@isempty, regexp([fieldnames(channelSpikes)].',feature2)));
            
            fns = fieldnames(channelSpikes);
            
            % for all spikes
            dim1_values_all = [channelSpikes.(fns{dim1_idx})].';
            dim2_values_all = [channelSpikes.(fns{dim2_idx})].';
            d1norm_all = normalize(dim1_values_all);
            d2norm_all = normalize(dim2_values_all);
            
            % for this neuron's spikes
            d1norm_neuron = d1norm_all(same_unit_idx);
            d2norm_neuron =  d2norm_all(same_unit_idx);
            
            % figure;
            hold on
            scatter( d1norm_all,d2norm_all,[],'k','filled');
            scatter( d1norm_neuron ,d2norm_neuron ,[],'r','filled');
            
            
        end
        
        
        function STA = calSTA(exp)
            
            % Extract spike information
            sptimes = exp.wavetimes;
            ylen = max(sptimes)*exp.e{1}.fs;
            psth = Cal.psth_SingleTrial(sptimes,ylen,exp.e{1}.fs);
            ids = find(psth ~= 0); % find those time bins which spike is not zero
            
            max_sptimes = max(sptimes);
            
            % Extract time information
            stimuli_info = struct;
            for w = 1: length(exp.e)
                stimuli_info(w).signal = exp.e{w}.rawy;
                
                stimuli_info(w).sigLen = length(exp.e{w}.rawy)/exp.e{w}.fs; % length of stimuli signals in seconds
                
                stimuli_info(w).triggerIni = exp.e{w}.trigger_onset; % also in seconds
            end
            
            collectIni = {stimuli_info.triggerIni}.';
            max_for_each_stimuli = cellfun(@max,collectIni);
            
            %             % just for testing
            %             temp = horzcat(collectIni{:});
            %             figure;
            %             hold on
            %             scatter(temp,repmat(1,length(temp),1));
            %             scatter(ids/1000,repmat(2,length(ids/1000),1));
            
            
            
            [maxtime,imax] = max ( max_for_each_stimuli );
            
            max_stimuli_end_time = maxtime + stimuli_info(imax).sigLen;
            
            %
            % generate the recovered stimuli time series
            
            recovered_y = zeros(int64(max(max_sptimes,max_stimuli_end_time)*exp.e{1}.fs),1);
            
            for s = 1: length(stimuli_info)
                initimes = stimuli_info(s).triggerIni;
                for b = 1:length(initimes)
                    i_time = int64(initimes(b)*exp.e{1}.fs);
                    e_time = int64(i_time + length(stimuli_info(s).signal)-1);
                    recovered_y(i_time:e_time)= stimuli_info(s).signal;
                end
            end
            
            % calculate STA
            pre_spikebin_window = 300 ;% ms
            
            pre_signal = []; % spectral-temporal vector
            for k = 1: length(ids)
                
                event_time_in_second = ids(k)/1000;
                
                if event_time_in_second < pre_spikebin_window/1000
                    pre_signal(k,:) = [zeros( int64((pre_spikebin_window/1000 - event_time_in_second)*exp.e{1}.fs),1);recovered_y(1:event_time_in_second*exp.e{1}.fs)];
                else
                    pre_signal(k,:) = recovered_y(event_time_in_second*exp.e{1}.fs-pre_spikebin_window/1000*exp.e{1}.fs+1:event_time_in_second*exp.e{1}.fs);
                end
            end
            
            vectors = {};
            for w = 1: size(pre_signal,1)
                vectors{w} = Cal.spec(pre_signal(w,:),exp.e{1}.fs)*psth(ids(w)) ;
            end
            
            sta = flip(sum(cat(3,vectors{:}),3)/sum(psth));
            
            figure;
            
            imagesc([1 size(sta,2)],[size(sta,1) 1],sta);
            xt = linspace(0, size(sta,2),6);
            xtlbl = flip(- linspace(0, pre_spikebin_window,6));
            
            set(gca, 'XTick',xt, 'XTickLabel',xtlbl);
            
            yt = linspace(0, size(sta,1),5);
            ytlbl = flip(linspace(0, 1600,5));
            
            set(gca, 'YTick',yt, 'YTickLabel',ytlbl);
            
            xlabel('Time (ms)','Interpreter','none');
            ylabel('Freq ');
            title( exp.neuronname,'Interpreter','none');
            
            saveas(gcf,sprintf('STA-%s.png',exp.neuronname));
            close(gcf);
        end
        
        function songE = extractEphysObjectOfIntactSongs(exp)
            
            songE = {};
            counts = 0;
            
            for k = 1: length(exp.e)
                if ~isempty(regexp(exp.e{k}.sound.name,'norm'))
                    counts= counts + 1;
                    songE{counts} = exp.e{k};
                end
            end
            
        end
        
        function resp_info = extractInfoOfResponseToWithinSongFrags(exp)
            % judge and Extract neural response to songs
            songE = extractEphysObjectOfIntactSongs(exp);
            
            if isempty(songE)
                resp_info = struct([]);
                return
            end
            
            latency = exp.cal_latency;
            
            
            % get a list of response to fragments within song,label frags
            resp_inf_collect = {};
            
            for k = 1: length(songE)
                
                %songE{k}.getSigRespnse
                % sylidx = songE{k}.getIndexOfSigSyllable(latency);
                songE{k}.sound.updateSeg; % update segmentation info
                resp_inf_collect{k} = songE{k}.JudgeRespToWIthinSongFrags_fromStimuliToResponse(latency)
                
            end
            
            resp_info = horzcat(resp_inf_collect{:});
            
            
            
            % corresponding to response spikes with response strength, while
            % others will be labelded as response as zero
            
            
            
        end
        
        function siginfo = findRespElicitingElementsOfThisNeuron(exp)
            
            siginfo = struct;
            count = 0;
            exp.fix_segmentation;
            
            for k = 1: length(exp.e)
                fragids = exp.e{k}.getIndexOfSigSyllable;
                for kk = 1: length(fragids)
                    count = count + 1;
                    siginfo(count).songname = exp.e{k}.sound.name;
                    siginfo(count).songid = regexp(exp.e{k}.sound.name,'[OBRYGX]\d+(TUT|BOS)?|Fcall}Mcall|Het|HET|WNS','match');
                    siginfo(count).fragid = fragids(kk);
                end
                
            end
            
        end
        
        
        function copyRespElements(exp)
            siginfo = exp.findRespElicitingElementsOfThisNeuron;
            siginfo = stimuli.expand_siginfo(siginfo,2);
            stimuli.fromConRespCopyResponsiveFrags(siginfo);
            
        end
        
        function figmat = writeFigdata(exp)
            
            figmat = struct;
            
            % Draw PltThree
            for idx = 1: length(exp.e)
                exp.e{idx}.pltthree(0);
                frame = getframe(gcf);
                close(gcf);
                figmat(idx).image = frame.cdata;
                figmat(idx).imagename = exp.e{idx}.sound.name;
            end
            
            % Draw Waveform PC12 ValleyTime PC1Time
            
            figure('Position',exp.figsize,'Color','w');
            exp.draw_waveform;     % draw waveform
            frame = getframe(gcf);
            close(gcf);
            figmat(idx + 1).image = frame.cdata;
            figmat(idx + 1).imagename = sprintf('%s_waveform',exp.neuronname);
            
            exp.drawPC12;
            frame = getframe(gcf);
            close(gcf);
            figmat(idx + 2).image = frame.cdata;
            figmat(idx + 2).imagename = sprintf('%s_pc12',exp.neuronname);
            
            
            exp.drawValleyVsTime;
            frame = getframe(gcf);
            close(gcf);
            figmat(idx + 3).image = frame.cdata;
            figmat(idx + 3).imagename = sprintf('%s_valleytime',exp.neuronname);
            
            exp.drawPC1VsTime;
            frame = getframe(gcf);
             close(gcf);
            figmat(idx + 3).image = frame.cdata;
            figmat(idx + 3).imagename = sprintf('%s_pc1time',exp.neuronname);
            
        end
        
        
        function [others,singlestruct] = collectImages(exp)
            
            singlestruct = struct;
            error = struct;
            for r = 1: length(exp.e)
 
                singlestruct(r).plxname = exp.plxname;
                singlestruct(r).channelunit = exp.channelunit;
                singlestruct(r).soundpath = exp.e{r}.sound.path;
                
                if ~isempty(regexp(singlestruct(r).soundpath,'Frag'))
                    ext = 0.5; % when tested sound is a frag
                else
                    ext = 1;   % not a frag
                end
                singlestruct(r).specimg = exp.e{r}.drawsaveSpec(ext);
                singlestruct(r).rasterimg = exp.e{r}.drawsaveRaster(ext);
                
            end
           
            exp.drawWaveform;
            others.waveform = getframe(gcf).cdata;
        end
    end
    
    methods  % 作图方法
        
       
        function drawPC12(exp)

            figure('Position',exp.figsize,'Color','w');
            hold on
            scatter(exp.sameChannelSpikes.pc1,exp.sameChannelSpikes.pc2,2,'k','filled');
            scatter(exp.wavepc(:,1),exp.wavepc(:,2),2,'r','filled');
            xlabel('PC1');
            ylabel('PC2');
        end
        
        function drawValleyVsTime(exp)
            
            if ismember('valley', exp.sameChannelSpikes.Properties.VariableNames)
                figure('Position',exp.figsize,'Color','w');
                hold on
                scatter(exp.sameChannelSpikes.valley,exp.sameChannelSpikes.timestamp,2,'k','filled')
                scatter(exp.wavevalley,exp.wavetimes,2,'r','filled');
                xlabel('Valley');
            ylabel('Time');
                
                
            else
                disp('Hey, you haven''t export the valley data of this Experiment');
                
            end
        end
        
        function drawPC1VsTime(exp)
            figure('Position',exp.figsize,'Color','w');
            hold on
            scatter(exp.sameChannelSpikes.pc1,exp.sameChannelSpikes.timestamp,1.5,'k','filled')
            scatter(exp.wavepc(:,1),exp.wavetimes,1.5,'r','filled');
        end
        
        function drawWaveform(exp)
            
            this_waveform =  exp.waveform;
            
            figure('Position',PM.size1,'Color','w');
            hold on
            plot(this_waveform.','Color',[.5,.5,.5]);
            plot(max(this_waveform),'--','Color','blue');
            plot(min(this_waveform),'--','Color','blue');
            plot(mean(this_waveform),'Color','red');
            hold off
        end
        
        function IMG = pltthree(exp,mode) % draw three plot
            
            % Judge which mode to use
            if ~exist('mode','var')
                mode = 0; % default mode is 0
            end
             
            enames = {};
            for idx = 1: length(exp.e)
                exp.e{idx}.pltthree(0);   enames{idx} = exp.e{idx}.sound.name;
                frame = getframe(gcf);  I{idx} = frame.cdata;  close(gcf);
            end
            
            
            if mode == 1 % MODE-1 arrange figure acoording to the birdnames
                
                % ids of different types of stimuli
                normids = find(~cellfun(@isempty, regexp(cellstr(enames.'),'norm')));
                mirids = find(~cellfun(@isempty, regexp(cellstr(enames.'),'mirror')));
                revids = find(~cellfun(@isempty, regexp(cellstr(enames.'),'reverse')));
                degids = find(~cellfun(@isempty, regexp(cellstr(enames.'),'deg|Deg')));
                replaids = find(~cellfun(@isempty, regexp(cellstr(enames.'),'Catego|catego|repla|Repla')));
                fragids = find(~cellfun(@isempty, regexp(cellstr(enames.'),'Frag|Syl|syl')));
                garfids = find(~cellfun(@isempty, regexp(cellstr(enames.'),'Garf|garf')));
                otherids = setdiff([1:length(exp.e)].',[normids;mirids;revids;degids;replaids;fragids;garfids]);
                
                % get all the birdnames appeared within the stimuli set
                modi_bnames1 = regexp(cellstr([enames{setdiff([1:length(exp.e)].',replaids)}]).','[OGBYR]\d{3}|Fcall|Mcall|Het','match');
                modi_bnames1 = horzcat(modi_bnames1{:}); % 非repla的stimuli对应的birdnames
                fct1 = @(x) split(x,'-before'); fct2 = @(x) x{1}; % 这个trick很好！
                repla_enames = cellfun(@(x) fct2(fct1(x)),cellstr({enames{replaids}}.'),'Uni',0);
                modi_bnames2 = regexp(cellstr(repla_enames),'[OGBYR]\d{3}|Fcall|Mcall|Het','match'); % repla的stimuli对应的birdnames
                modi_bnames2 = horzcat(modi_bnames2{:});
                modi_bnames = unique(vertcat(modi_bnames1.',modi_bnames2.'));
                
                % rearrange all the figures
                figure_map = {};
                for k = 1:length(modi_bnames)
                    derivatives = find(~cellfun(@isempty,regexp(cellstr(enames.'),modi_bnames{k})));
                    sub_norm = intersect(normids,derivatives);
                    sub_rev = intersect(revids,derivatives);
                    sub_mir = intersect(mirids,derivatives);
                    sub_deg = intersect(degids,derivatives);
                    sub_frag = intersect(fragids,derivatives);
                    sub_other = intersect(otherids,derivatives);
                    repla = intersect(replaids,derivatives);
                    figure_map{k} = [sub_norm(:);sub_rev(:);sub_mir(:);sub_deg(:);sub_frag(:)]; % force each to be column vectors
                end
                [~,idx] = sort(cellfun(@length,figure_map),'descend');
                figure_map = figure_map(idx);
                Icollect = {};
                for k = 1:length(figure_map)
                    Icollect{k} = {I{figure_map{k}}}.' ;
                end
                exp.drawWaveform;     % draw waveform
                frame = getframe(gcf);
                Icollect{length( Icollect) + 1} = {frame.cdata};
                close(gcf);
                Iall = Convert.mergeImage(Icollect);
                imwrite(Iall,sprintf('Three_%s.png',exp.neuronname));
                return
            end
            
            
            % This is Mode-zero
            exp.drawWaveform;     % draw waveform
            frame = getframe(gcf);
            I{length( I) + 1} = frame.cdata;
                
            if length(I) > 30; lieshu = 9;
            else;lieshu = 6; end;
            
            hangshu = ceil(length(I)/lieshu);
            rest = lieshu*hangshu - length(I);
            white = uint8(255*ones(size(I{1})));
            
            if rest > 0
                for k = 1:rest;I = [I,white];end;
            end
            
            reshapedI = reshape(I, lieshu,[])';clear I;
            Iall = cell2mat(reshapedI);
            imwrite(Iall,sprintf('Three_%s.png',exp.neuronname));
            
        end
        
          function IMG = Two(exp) % draw three plot
            
%             enames = {};
%             for k = 1:length(exp.e)
%                 enames{k} = exp.e{k}.sound.name;
%             end
%              conkeywords = {'B346','B512','B521','B554','B606','G429','G506','G518','G548','G573',...
%                 'G578','O331','O507','O509','O540','Y515','Y606','Y616'};
%             
%     
%            selected_ids = find(~cellfun(@isempty, regexp(cellstr(enames),strjoin(conkeywords,'|'))));
%             
%             
            
            
            for idx = 1: length(exp.e)
                exp.e{idx}.two;%_with_sig_resp; % newer version of threeplot drawing method
                frame = getframe(gcf);
                I{idx} = frame.cdata;
                close(gcf);
            end
            %
            %exp.draw_waveform;     % draw waveform
%             frame = getframe(gcf);
%             I{length(I)+ 1} = frame.cdata;
%             close(gcf);
            
            % draw blank white
            if length(I) > 30
                lieshu = 9;
            else
                lieshu = 6;
            end
            
            hangshu = ceil(length(I)/lieshu);
            rest = lieshu*hangshu - length(I);
            white = uint8(255*ones(size(I{1})));
            
            if rest > 0
                for k = 1:rest
                    I = [I,white];
                    %                     ax = gcf;
                    %                     ax.Position(3) = 560;
                    %                     ax.Position(4) = 420;
                end
            end
            
            reshapedI = reshape(I, lieshu,[])';
            clear I
            IMG = cell2mat(reshapedI);
            imwrite(IMG,sprintf('Three_%s.png',exp.neuronname));
            
        end
        
        function IMG = OneRowThree(exp) % draw three plot
            
            
            for idx = 1: length(exp.e)
                exp.e{idx}.pltthree;
                %exp.e{idx}.Three;
                %exp.e{idx}.pltthree;%_with_sig_resp; % newer version of threeplot drawing method
                frame = getframe(gcf);
                I{idx} = frame.cdata;
                close(gcf);
            end
            %
            exp.drawWaveform;     % draw waveform
            frame = getframe(gcf);
            I{length(I)+ 1} = frame.cdata;
            close(gcf);
            
            figure('Position',PM.size1,'Color','w');
            text(0.020,0.5481,strrep(exp.neuronname,'_','-'),'FontSize',34);
            frame = getframe(gcf);
            I{length(I)+ 1} = frame.cdata;
            close(gcf);
            
            % draw blank white
            hangshu = 1;
            lieshu = ceil(length(I)/hangshu);
            rest = lieshu*hangshu - length(I);
            white = uint8(255*ones(size(I{1})));
            
            if rest > 0
                for k = 1:rest
                    I = [I,white];
                end
            end
            reshapedI = reshape(I, lieshu,[])';
            IMG = cell2mat(reshapedI);
      
            
        end
        
        
        function IMG = selected_pltthree(exp) % draw three plot
            
            enames = {}; I = {};
            for k = 1:length(exp.e)
                enames{k} = exp.e{k}.sound.name;
            end
            conkeywords = {'B346','B512','B521','B554','B606','G429','G506','G518','G548','G573',...
                'G578','O331','O507','O509','O540','Y515','Y606','Y616'};
            
            
            selected_ids = find(~cellfun(@isempty, regexp(cellstr(enames),strjoin(conkeywords,'|'))));  
            
            for k= 1: length(selected_ids)
                exp.e{selected_ids(k)}.pltthree(0); % set visibility to 0
                frame = getframe(gcf);
                I{k} = frame.cdata;
                close(gcf);
            end
            %
            exp.draw_waveform;     % draw waveform
            frame = getframe(gcf);
            I{length(I)+ 1} = frame.cdata;
            close(gcf);
            
            % draw blank white
            if length(I) > 30
                lieshu = 9;
            else
                lieshu = 6;
            end
            
            hangshu = ceil(length(I)/lieshu);
            rest = lieshu*hangshu - length(I);
            white = uint8(255*ones(size(I{1})));
            
            if rest > 0
                for k = 1:rest
                    I = [I,white];
                end
            end
            
            reshapedI = reshape(I, lieshu,[])';
            clear I
            IMG = cell2mat(reshapedI);
            imwrite(IMG,sprintf('Three_%s.png',exp.neuronname));
            
        end
        
        
          
        function IMG = rawthree(exp) % draw three plot
            
            for idx = 1: length(exp.e)
                exp.e{idx}.rawthree;
                frame = getframe(gcf);
                I{idx} = frame.cdata;
                close(gcf);
            end
            
            %figure('Position',exp.figsize,'Color','w');
%             exp.draw_waveform;     % draw waveform
%             frame = getframe(gcf);
%             I{length(I)+ 1} = frame.cdata;
%             close(gcf);
%             
%             exp.drawPC12;
%             frame = getframe(gcf);
%             I{length(I)+ 1} = frame.cdata;
%             close(gcf);
%             
%             exp.drawValleyVsTime;
%             frame = getframe(gcf);
%             I{length(I)+ 1} = frame.cdata;
%             close(gcf);
%             
%             exp.drawPC1VsTime;
%             frame = getframe(gcf);
%             I{length(I)+ 1} = frame.cdata;
%             close(gcf);
            
            % draw blank white
            if length(I) > 30
                lieshu = 15;
            else
                lieshu = 6;
            end
            hangshu = ceil(length(I)/lieshu);
            rest = lieshu*hangshu - length(I);
            white = uint8(255*ones(size(I{1})));
            
            if rest > 0
                for k = 1:rest
                    I = [I,white];
                    %                     ax = gcf;
                    %                     ax.Position(3) = 560;
                    %                     ax.Position(4) = 420;
                end
            end
            
            reshapedI = reshape(I, lieshu,[])';
            %clear I
            IMG = cell2mat(reshapedI);
            imwrite(IMG,sprintf('RawThree_%s.png',exp.neuronname));
            
        end
        
        function threePlotsWithFreqRelatedFeatures(exp)
            
            reordered_idx = Neuron(exp).reorder_three_plots;
            
            for idx = 1: length(exp.e)
                exp.e{reordered_idx(idx)}.threeWithFreqRelatedFeatures; % newer version of threeplot drawing method
                frame = getframe(gcf);
                I{idx} = frame.cdata;
                close(gcf);
            end
            
            figure('Visible','off','color','w');
            exp.draw_waveform;     % draw waveform
            frame = getframe(gcf);
            I{length(I)+ 1} = frame.cdata;
            close(gcf);
            
            figure('Visible','off','color','w');
            %hold on
            exp.draw_feature_distribution('pc1','pc2');     % draw waveform
            frame = getframe(gcf);
            I{length(I)+ 1} = frame.cdata;
            close(gcf);
            
            % draw blank white
            %             lieshu = 9;
            hangshu = ceil(length(I)/exp.lieshu);
            rest = exp.lieshu*hangshu - length(I);
            white = uint8(255*ones(size(I{1})));
            
            if rest > 0
                for k = 1:rest
                    I = [I,white];
                    %                     ax = gcf;
                    %                     ax.Position(3) = 560;
                    %                     ax.Position(4) = 420;
                end
            end
            
            reshapedI = reshape(I, exp.lieshu,[])';
            clear I
            IMG = cell2mat(reshapedI);
            imwrite(IMG,sprintf('Three_%s.png',exp.neuronname));
            
        end
        
        function  ResponseBasedOrderedThreePlots(exp) % previous name was Three
            wb = waitbar(0,'writting three plots...');
            
            reordered_idx = Neuron(exp).reorder_three_plots;
            for idx = 1: length(exp.e)
                waitbar(idx/length(exp.e),wb,'writting three plots...');
                exp.e{reordered_idx(idx)}.Three;
                frame = getframe(gcf);
                I{idx} = frame.cdata;
                close(gcf);
            end
            close(wb);
            
            figure('Visible','off','color','w')
            hold on
            exp.draw_waveform;     % draw waveform
            frame = getframe(gcf);
            I{length(I)+ 1} = frame.cdata;
            close(gcf);
            
            
            figure('Visible','off','color','w')
            %hold on
            exp.draw_feature_distribution('pc1','pc2');     % draw waveform
            frame = getframe(gcf);
            I{length(I)+ 1} = frame.cdata;
            close(gcf);
            
            
            hangshu = ceil(length(I)/exp.lieshu);
            rest = exp.lieshu*hangshu - length(I);
            white = uint8(255*ones(size(I{1})));
            
            if rest > 0
                for k = 1:rest
                    I = [I,white];
                end
            end
            
            reshapedI = reshape(I, exp.lieshu,[])';
            clear I
            IMG = cell2mat(reshapedI);
            pause(0.2)
            imwrite(IMG,sprintf('Three_%s.png',exp.neuronname));
        end
        
        function IMG = slendertwo(exp)
            wb = waitbar(0,'writting slender plots...');
            for idx = 1: length(exp.e)
                waitbar(idx/length(exp.e),wb,'writting three plots...');
                exp.e{idx}.slendertwo;
                frame = getframe(gcf);
                I{idx} = frame.cdata;
                close(gcf);
            end
            close(wb);
            
            figure('Visible','off','color','w','Position',[2104 35 468 1013])
            hold on
            exp.draw_waveform;     % draw waveform
            frame = getframe(gcf);
            I{length(I)+ 1} = frame.cdata;
            close(gcf);
            
            rest = exp.lieshu*exp.hangshu - length(I);
            white = uint8(255*ones(size(I{1})));
            
            if rest > 0
                for k = 1:rest
                    I = [I,white];
                end
            end
            
            reshapedI = reshape(I, exp.lieshu,[])';
            clear I
            IMG = cell2mat(reshapedI);
            pause(0.2)
            imwrite(IMG,sprintf('Three_%s.png',exp.neuronname));
            
        end
        
        function drawpre(exp)
            pre = preinf(exp);
            feature = {'pitch'};
            
            for feaN = 1: length(feature)
                
                featurename = feature{feaN};
                
                featurecell = eval(['{pre.',feature{feaN},'}.''']);
                allfea = horzcat(featurecell{:});
                
                allfea(allfea==0)=[];
                allfea(allfea==inf)=[];
                allfea(isnan(allfea))=[];
                
                
                figure('color','w','visible','off');
                ax = gcf;
                ax.Position(3) = 1120;
                ax.Position(4) = 840;
                
                data = cell2mat(eval(['{pre.',feature{feaN},'}.''']))';
                data(data == inf|data == -inf|data == 0) = NaN;
                
                %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                %
                %                 controldata = {};
                %                 PDFcontrol = {};
                %                 tic
                %                 parfor conN = 1
                %                     controlprespike = featureAlignControl2(response,range,length(prespike),feature{feaN});
                %                     controldata{conN} = cell2mat({controlprespike.thefeature}.')';
                %
                %                     controldata{conN}(controldata{conN} == inf|controldata{conN} == -inf|controldata{conN} == 0) = NaN;
                %                     [~,PDFcontrol{conN},~] = estDensityThesis(controldata{conN},prespike,1,featurename,1);
                %                     %disp(conN)
                %                 end
                %                 toc
                
                %                 sumPDF =  horzcat(PDFcontrol{:});
                %                 %     figure
                %                 %     histogram( max(sumPDF),'Normalization','Probability' );
                %
                %                 [countN, bedges] =  histcounts( max(sumPDF),'Normalization','Probability' );
                %
                %                 bin = 0;
                %                 probablity = 0;
                %                 while probablity < 0.95
                %                     bin = bin + 1;
                %                     probablity = probablity + countN(bin);
                %                 end
                %
                %                 threshold = ( bedges(bin) + bedges(bin+1) )/2;
                %
                
                %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                [Ia,DFdata,limcolor] = estDensityThesis(data, pre, [],featurename);
                
                
                figure;
                plot(data);
                tempI = getframe(gcf);
                Itrace{feaN} = tempI.cdata;
                
                %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% last part
                Ifea{feaN} = Ia;
                
                close(gcf);
            end
            
            I = vertcat(Ifea{:});
            
        end  % have to modify a lot to use this function
        
        function imgstruct = calImage(exp)
            for k = 1: length(exp.e)
                exp.e{1}.two
            end
        end
            
 
        
    end

   
    methods(Static) %静态方法  
        function sorted_data = extractFeaturesFromSapRawData(path_data_json_or_txt, path_info_json_or_txt)
            dbstop if error
            [~,~,dataext] = fileparts(path_data_json_or_txt);
            [~,~,infoext] = fileparts(path_info_json_or_txt);
            
            if strcmp(dataext, ".json")
                data = Extract.json(path_data_json_or_txt); %如果文件是json file的话
            elseif strcmp(dataext, ".txt")
                data = table2struct(readtable(path_data_json_or_txt));
            end
            
            if strcmp(infoext, ".json")
                info = Extract.json(path_info_json_or_txt); %如果文件是json file的话
            elseif strcmp(infoext, ".txt")
                info = table2struct(readtable(path_info_json_or_txt));
            end
            
            
            sorted_data = struct('file_index', {info(:).file_index}, 'file_name', {info(:).file_name});
            
            for k = 1: length(sorted_data)
                
                dataids = find([data.file_index].' == sorted_data(k).file_index);
                local_data = data(dataids); % allocate feature of this (k) stimuli
                sorted_data(k).amplitude = [local_data.amplitude].';
                sorted_data(k).mean_frequency_amp = [local_data.mean_frequency_amp].';
                sorted_data(k).pitch = [local_data.pitch].';
                sorted_data(k).mean_frequency = [local_data.mean_frequency].';
                sorted_data(k).FM = [local_data.FM].';
                sorted_data(k).AM = [local_data.am].';
                sorted_data(k).goodness = [local_data.goodness].';
                sorted_data(k).entropy = [local_data.entropy].';
                sorted_data(k).peak_frequency = [local_data.peak_frequency].';
                sorted_data(k).continuity_t = [local_data.continuity_t].';
                sorted_data(k).continuity_f = [local_data.continuity_f].';
                
            end
            
        end
    end
    
    
 end
    


    
    


    
   
 
 
 


    



